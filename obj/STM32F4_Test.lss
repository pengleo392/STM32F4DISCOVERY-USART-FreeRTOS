
obj/STM32F4_Test.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00008000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000241c  08000188  08000188  00008188  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .init_array   00000008  080025a4  080025a4  0000a5a4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .fini_array   00000004  080025ac  080025ac  0000a5ac  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .data         00000544  20000000  080025b0  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          0000025c  20000548  08002af4  00010548  2**3
                  ALLOC
  6 ._user_heap_stack 00000400  200007a4  08002af4  000107a4  2**0
                  ALLOC
  7 .ARM.attributes 00000033  00000000  00000000  00010544  2**0
                  CONTENTS, READONLY
  8 .debug_abbrev 00003cf6  00000000  00000000  00010577  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   000164d4  00000000  00000000  0001426d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00009128  00000000  00000000  0002a741  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00009ccc  00000000  00000000  00033869  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 000040c5  00000000  00000000  0003d535  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 00001f5a  00000000  00000000  000415fa  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 00001af8  00000000  00000000  00043554  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 000018a8  00000000  00000000  0004504c  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    000080cb  00000000  00000000  000468f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000002a  00000000  00000000  0004e9bf  2**0
                  CONTENTS, READONLY
 18 .debug_frame  00006404  00000000  00000000  0004e9ec  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000188 <__do_global_dtors_aux>:
 8000188:	f240 5348 	movw	r3, #1352	; 0x548
 800018c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000190:	781a      	ldrb	r2, [r3, #0]
 8000192:	b90a      	cbnz	r2, 8000198 <__do_global_dtors_aux+0x10>
 8000194:	2001      	movs	r0, #1
 8000196:	7018      	strb	r0, [r3, #0]
 8000198:	4770      	bx	lr
 800019a:	bf00      	nop

0800019c <frame_dummy>:
 800019c:	f240 5044 	movw	r0, #1348	; 0x544
 80001a0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80001a4:	b508      	push	{r3, lr}
 80001a6:	6803      	ldr	r3, [r0, #0]
 80001a8:	b12b      	cbz	r3, 80001b6 <frame_dummy+0x1a>
 80001aa:	f240 0300 	movw	r3, #0
 80001ae:	f2c0 0300 	movt	r3, #0
 80001b2:	b103      	cbz	r3, 80001b6 <frame_dummy+0x1a>
 80001b4:	4798      	blx	r3
 80001b6:	bd08      	pop	{r3, pc}

080001b8 <__libc_init_array>:
 80001b8:	b570      	push	{r4, r5, r6, lr}
 80001ba:	f242 56a4 	movw	r6, #9636	; 0x25a4
 80001be:	f242 55a4 	movw	r5, #9636	; 0x25a4
 80001c2:	f6c0 0600 	movt	r6, #2048	; 0x800
 80001c6:	f6c0 0500 	movt	r5, #2048	; 0x800
 80001ca:	1b76      	subs	r6, r6, r5
 80001cc:	10b6      	asrs	r6, r6, #2
 80001ce:	d006      	beq.n	80001de <__libc_init_array+0x26>
 80001d0:	2400      	movs	r4, #0
 80001d2:	f855 3b04 	ldr.w	r3, [r5], #4
 80001d6:	3401      	adds	r4, #1
 80001d8:	4798      	blx	r3
 80001da:	42a6      	cmp	r6, r4
 80001dc:	d1f9      	bne.n	80001d2 <__libc_init_array+0x1a>
 80001de:	f242 56ac 	movw	r6, #9644	; 0x25ac
 80001e2:	f242 55a4 	movw	r5, #9636	; 0x25a4
 80001e6:	f6c0 0600 	movt	r6, #2048	; 0x800
 80001ea:	f6c0 0500 	movt	r5, #2048	; 0x800
 80001ee:	1b76      	subs	r6, r6, r5
 80001f0:	f002 f9cc 	bl	800258c <_init>
 80001f4:	10b6      	asrs	r6, r6, #2
 80001f6:	d006      	beq.n	8000206 <__libc_init_array+0x4e>
 80001f8:	2400      	movs	r4, #0
 80001fa:	f855 3b04 	ldr.w	r3, [r5], #4
 80001fe:	3401      	adds	r4, #1
 8000200:	4798      	blx	r3
 8000202:	42a6      	cmp	r6, r4
 8000204:	d1f9      	bne.n	80001fa <__libc_init_array+0x42>
 8000206:	bd70      	pop	{r4, r5, r6, pc}

08000208 <malloc>:
 8000208:	f240 0300 	movw	r3, #0
 800020c:	4601      	mov	r1, r0
 800020e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000212:	6818      	ldr	r0, [r3, #0]
 8000214:	f000 b808 	b.w	8000228 <_malloc_r>

08000218 <free>:
 8000218:	f240 0300 	movw	r3, #0
 800021c:	4601      	mov	r1, r0
 800021e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000222:	6818      	ldr	r0, [r3, #0]
 8000224:	f000 bc58 	b.w	8000ad8 <_free_r>

08000228 <_malloc_r>:
 8000228:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800022c:	f101 040b 	add.w	r4, r1, #11
 8000230:	2c16      	cmp	r4, #22
 8000232:	b083      	sub	sp, #12
 8000234:	4606      	mov	r6, r0
 8000236:	d931      	bls.n	800029c <_malloc_r+0x74>
 8000238:	f024 0407 	bic.w	r4, r4, #7
 800023c:	0fe3      	lsrs	r3, r4, #31
 800023e:	428c      	cmp	r4, r1
 8000240:	bf2c      	ite	cs
 8000242:	4619      	movcs	r1, r3
 8000244:	f043 0101 	orrcc.w	r1, r3, #1
 8000248:	2900      	cmp	r1, #0
 800024a:	d130      	bne.n	80002ae <_malloc_r+0x86>
 800024c:	4630      	mov	r0, r6
 800024e:	f001 f897 	bl	8001380 <__malloc_lock>
 8000252:	f5b4 7ffc 	cmp.w	r4, #504	; 0x1f8
 8000256:	d22f      	bcs.n	80002b8 <_malloc_r+0x90>
 8000258:	ea4f 0cd4 	mov.w	ip, r4, lsr #3
 800025c:	f240 05f4 	movw	r5, #244	; 0xf4
 8000260:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8000264:	eb05 02cc 	add.w	r2, r5, ip, lsl #3
 8000268:	462f      	mov	r7, r5
 800026a:	68d3      	ldr	r3, [r2, #12]
 800026c:	4293      	cmp	r3, r2
 800026e:	f000 822d 	beq.w	80006cc <_malloc_r+0x4a4>
 8000272:	685c      	ldr	r4, [r3, #4]
 8000274:	f103 0808 	add.w	r8, r3, #8
 8000278:	68da      	ldr	r2, [r3, #12]
 800027a:	4630      	mov	r0, r6
 800027c:	f024 0403 	bic.w	r4, r4, #3
 8000280:	6899      	ldr	r1, [r3, #8]
 8000282:	191b      	adds	r3, r3, r4
 8000284:	685c      	ldr	r4, [r3, #4]
 8000286:	60ca      	str	r2, [r1, #12]
 8000288:	f044 0401 	orr.w	r4, r4, #1
 800028c:	6091      	str	r1, [r2, #8]
 800028e:	605c      	str	r4, [r3, #4]
 8000290:	f001 f880 	bl	8001394 <__malloc_unlock>
 8000294:	4640      	mov	r0, r8
 8000296:	b003      	add	sp, #12
 8000298:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800029c:	2300      	movs	r3, #0
 800029e:	2410      	movs	r4, #16
 80002a0:	428c      	cmp	r4, r1
 80002a2:	bf2c      	ite	cs
 80002a4:	4619      	movcs	r1, r3
 80002a6:	f043 0101 	orrcc.w	r1, r3, #1
 80002aa:	2900      	cmp	r1, #0
 80002ac:	d0ce      	beq.n	800024c <_malloc_r+0x24>
 80002ae:	230c      	movs	r3, #12
 80002b0:	f04f 0800 	mov.w	r8, #0
 80002b4:	6033      	str	r3, [r6, #0]
 80002b6:	e7ed      	b.n	8000294 <_malloc_r+0x6c>
 80002b8:	ea5f 2c54 	movs.w	ip, r4, lsr #9
 80002bc:	bf04      	itt	eq
 80002be:	ea4f 0cd4 	moveq.w	ip, r4, lsr #3
 80002c2:	ea4f 00cc 	moveq.w	r0, ip, lsl #3
 80002c6:	f040 8086 	bne.w	80003d6 <_malloc_r+0x1ae>
 80002ca:	f240 05f4 	movw	r5, #244	; 0xf4
 80002ce:	f2c2 0500 	movt	r5, #8192	; 0x2000
 80002d2:	1828      	adds	r0, r5, r0
 80002d4:	462f      	mov	r7, r5
 80002d6:	68c3      	ldr	r3, [r0, #12]
 80002d8:	4298      	cmp	r0, r3
 80002da:	d106      	bne.n	80002ea <_malloc_r+0xc2>
 80002dc:	e00d      	b.n	80002fa <_malloc_r+0xd2>
 80002de:	2900      	cmp	r1, #0
 80002e0:	f280 8179 	bge.w	80005d6 <_malloc_r+0x3ae>
 80002e4:	68db      	ldr	r3, [r3, #12]
 80002e6:	4298      	cmp	r0, r3
 80002e8:	d007      	beq.n	80002fa <_malloc_r+0xd2>
 80002ea:	685a      	ldr	r2, [r3, #4]
 80002ec:	f022 0203 	bic.w	r2, r2, #3
 80002f0:	1b11      	subs	r1, r2, r4
 80002f2:	290f      	cmp	r1, #15
 80002f4:	ddf3      	ble.n	80002de <_malloc_r+0xb6>
 80002f6:	f10c 3cff 	add.w	ip, ip, #4294967295
 80002fa:	f10c 0c01 	add.w	ip, ip, #1
 80002fe:	4abd      	ldr	r2, [pc, #756]	; (80005f4 <_malloc_r+0x3cc>)
 8000300:	6893      	ldr	r3, [r2, #8]
 8000302:	429a      	cmp	r2, r3
 8000304:	bf08      	it	eq
 8000306:	6878      	ldreq	r0, [r7, #4]
 8000308:	d024      	beq.n	8000354 <_malloc_r+0x12c>
 800030a:	6858      	ldr	r0, [r3, #4]
 800030c:	f020 0003 	bic.w	r0, r0, #3
 8000310:	1b01      	subs	r1, r0, r4
 8000312:	290f      	cmp	r1, #15
 8000314:	f300 81c0 	bgt.w	8000698 <_malloc_r+0x470>
 8000318:	2900      	cmp	r1, #0
 800031a:	60d2      	str	r2, [r2, #12]
 800031c:	6092      	str	r2, [r2, #8]
 800031e:	f280 8094 	bge.w	800044a <_malloc_r+0x222>
 8000322:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8000326:	f080 8177 	bcs.w	8000618 <_malloc_r+0x3f0>
 800032a:	08c0      	lsrs	r0, r0, #3
 800032c:	f04f 0e01 	mov.w	lr, #1
 8000330:	f8d7 8004 	ldr.w	r8, [r7, #4]
 8000334:	eb07 01c0 	add.w	r1, r7, r0, lsl #3
 8000338:	1080      	asrs	r0, r0, #2
 800033a:	fa0e f000 	lsl.w	r0, lr, r0
 800033e:	60d9      	str	r1, [r3, #12]
 8000340:	f8d1 e008 	ldr.w	lr, [r1, #8]
 8000344:	ea40 0008 	orr.w	r0, r0, r8
 8000348:	6078      	str	r0, [r7, #4]
 800034a:	f8c3 e008 	str.w	lr, [r3, #8]
 800034e:	f8ce 300c 	str.w	r3, [lr, #12]
 8000352:	608b      	str	r3, [r1, #8]
 8000354:	f04f 0e01 	mov.w	lr, #1
 8000358:	ea4f 03ac 	mov.w	r3, ip, asr #2
 800035c:	fa0e fe03 	lsl.w	lr, lr, r3
 8000360:	4586      	cmp	lr, r0
 8000362:	d87d      	bhi.n	8000460 <_malloc_r+0x238>
 8000364:	ea10 0f0e 	tst.w	r0, lr
 8000368:	d108      	bne.n	800037c <_malloc_r+0x154>
 800036a:	f02c 0c03 	bic.w	ip, ip, #3
 800036e:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 8000372:	f10c 0c04 	add.w	ip, ip, #4
 8000376:	ea10 0f0e 	tst.w	r0, lr
 800037a:	d0f8      	beq.n	800036e <_malloc_r+0x146>
 800037c:	eb07 0acc 	add.w	sl, r7, ip, lsl #3
 8000380:	46e1      	mov	r9, ip
 8000382:	46d0      	mov	r8, sl
 8000384:	f8d8 000c 	ldr.w	r0, [r8, #12]
 8000388:	4580      	cmp	r8, r0
 800038a:	d107      	bne.n	800039c <_malloc_r+0x174>
 800038c:	e196      	b.n	80006bc <_malloc_r+0x494>
 800038e:	2b00      	cmp	r3, #0
 8000390:	f280 81a6 	bge.w	80006e0 <_malloc_r+0x4b8>
 8000394:	68c0      	ldr	r0, [r0, #12]
 8000396:	4580      	cmp	r8, r0
 8000398:	f000 8190 	beq.w	80006bc <_malloc_r+0x494>
 800039c:	6841      	ldr	r1, [r0, #4]
 800039e:	f021 0103 	bic.w	r1, r1, #3
 80003a2:	1b0b      	subs	r3, r1, r4
 80003a4:	2b0f      	cmp	r3, #15
 80003a6:	ddf2      	ble.n	800038e <_malloc_r+0x166>
 80003a8:	4680      	mov	r8, r0
 80003aa:	68c5      	ldr	r5, [r0, #12]
 80003ac:	1901      	adds	r1, r0, r4
 80003ae:	f044 0e01 	orr.w	lr, r4, #1
 80003b2:	f858 7f08 	ldr.w	r7, [r8, #8]!
 80003b6:	f043 0401 	orr.w	r4, r3, #1
 80003ba:	f8c0 e004 	str.w	lr, [r0, #4]
 80003be:	4630      	mov	r0, r6
 80003c0:	604c      	str	r4, [r1, #4]
 80003c2:	60fd      	str	r5, [r7, #12]
 80003c4:	60af      	str	r7, [r5, #8]
 80003c6:	60d1      	str	r1, [r2, #12]
 80003c8:	6091      	str	r1, [r2, #8]
 80003ca:	60ca      	str	r2, [r1, #12]
 80003cc:	608a      	str	r2, [r1, #8]
 80003ce:	50cb      	str	r3, [r1, r3]
 80003d0:	f000 ffe0 	bl	8001394 <__malloc_unlock>
 80003d4:	e75e      	b.n	8000294 <_malloc_r+0x6c>
 80003d6:	f1bc 0f04 	cmp.w	ip, #4
 80003da:	bf9e      	ittt	ls
 80003dc:	ea4f 1c94 	movls.w	ip, r4, lsr #6
 80003e0:	f10c 0c38 	addls.w	ip, ip, #56	; 0x38
 80003e4:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 80003e8:	f67f af6f 	bls.w	80002ca <_malloc_r+0xa2>
 80003ec:	f1bc 0f14 	cmp.w	ip, #20
 80003f0:	bf9c      	itt	ls
 80003f2:	f10c 0c5b 	addls.w	ip, ip, #91	; 0x5b
 80003f6:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 80003fa:	f67f af66 	bls.w	80002ca <_malloc_r+0xa2>
 80003fe:	f1bc 0f54 	cmp.w	ip, #84	; 0x54
 8000402:	bf9e      	ittt	ls
 8000404:	ea4f 3c14 	movls.w	ip, r4, lsr #12
 8000408:	f10c 0c6e 	addls.w	ip, ip, #110	; 0x6e
 800040c:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 8000410:	f67f af5b 	bls.w	80002ca <_malloc_r+0xa2>
 8000414:	f5bc 7faa 	cmp.w	ip, #340	; 0x154
 8000418:	bf9e      	ittt	ls
 800041a:	ea4f 3cd4 	movls.w	ip, r4, lsr #15
 800041e:	f10c 0c77 	addls.w	ip, ip, #119	; 0x77
 8000422:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 8000426:	f67f af50 	bls.w	80002ca <_malloc_r+0xa2>
 800042a:	f240 5354 	movw	r3, #1364	; 0x554
 800042e:	459c      	cmp	ip, r3
 8000430:	bf95      	itete	ls
 8000432:	ea4f 4c94 	movls.w	ip, r4, lsr #18
 8000436:	f44f 707c 	movhi.w	r0, #1008	; 0x3f0
 800043a:	f10c 0c7c 	addls.w	ip, ip, #124	; 0x7c
 800043e:	f04f 0c7e 	movhi.w	ip, #126	; 0x7e
 8000442:	bf98      	it	ls
 8000444:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 8000448:	e73f      	b.n	80002ca <_malloc_r+0xa2>
 800044a:	181a      	adds	r2, r3, r0
 800044c:	f103 0808 	add.w	r8, r3, #8
 8000450:	4630      	mov	r0, r6
 8000452:	6853      	ldr	r3, [r2, #4]
 8000454:	f043 0301 	orr.w	r3, r3, #1
 8000458:	6053      	str	r3, [r2, #4]
 800045a:	f000 ff9b 	bl	8001394 <__malloc_unlock>
 800045e:	e719      	b.n	8000294 <_malloc_r+0x6c>
 8000460:	f8d7 8008 	ldr.w	r8, [r7, #8]
 8000464:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8000468:	f023 0903 	bic.w	r9, r3, #3
 800046c:	454c      	cmp	r4, r9
 800046e:	ebc4 0209 	rsb	r2, r4, r9
 8000472:	bf94      	ite	ls
 8000474:	2300      	movls	r3, #0
 8000476:	2301      	movhi	r3, #1
 8000478:	2a0f      	cmp	r2, #15
 800047a:	bfd8      	it	le
 800047c:	f043 0301 	orrle.w	r3, r3, #1
 8000480:	2b00      	cmp	r3, #0
 8000482:	f000 80b9 	beq.w	80005f8 <_malloc_r+0x3d0>
 8000486:	f240 5a4c 	movw	sl, #1356	; 0x54c
 800048a:	f8d5 3408 	ldr.w	r3, [r5, #1032]	; 0x408
 800048e:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 8000492:	4630      	mov	r0, r6
 8000494:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000498:	f8da 2000 	ldr.w	r2, [sl]
 800049c:	f102 0b10 	add.w	fp, r2, #16
 80004a0:	44a3      	add	fp, r4
 80004a2:	bf1f      	itttt	ne
 80004a4:	f50b 6b7e 	addne.w	fp, fp, #4064	; 0xfe0
 80004a8:	f10b 0b1f 	addne.w	fp, fp, #31
 80004ac:	f42b 6b7e 	bicne.w	fp, fp, #4064	; 0xfe0
 80004b0:	f02b 0b1f 	bicne.w	fp, fp, #31
 80004b4:	4659      	mov	r1, fp
 80004b6:	f000 ff2d 	bl	8001314 <_sbrk_r>
 80004ba:	f1b0 3fff 	cmp.w	r0, #4294967295
 80004be:	4603      	mov	r3, r0
 80004c0:	f000 8118 	beq.w	80006f4 <_malloc_r+0x4cc>
 80004c4:	eb08 0109 	add.w	r1, r8, r9
 80004c8:	4281      	cmp	r1, r0
 80004ca:	f200 8110 	bhi.w	80006ee <_malloc_r+0x4c6>
 80004ce:	f8da 2004 	ldr.w	r2, [sl, #4]
 80004d2:	4281      	cmp	r1, r0
 80004d4:	445a      	add	r2, fp
 80004d6:	f8ca 2004 	str.w	r2, [sl, #4]
 80004da:	f000 813e 	beq.w	800075a <_malloc_r+0x532>
 80004de:	f8d5 e408 	ldr.w	lr, [r5, #1032]	; 0x408
 80004e2:	f240 05f4 	movw	r5, #244	; 0xf4
 80004e6:	f2c2 0500 	movt	r5, #8192	; 0x2000
 80004ea:	f1be 3fff 	cmp.w	lr, #4294967295
 80004ee:	bf17      	itett	ne
 80004f0:	1882      	addne	r2, r0, r2
 80004f2:	f8c5 0408 	streq.w	r0, [r5, #1032]	; 0x408
 80004f6:	ebc1 0102 	rsbne	r1, r1, r2
 80004fa:	f8ca 1004 	strne.w	r1, [sl, #4]
 80004fe:	f010 0507 	ands.w	r5, r0, #7
 8000502:	bf17      	itett	ne
 8000504:	f1c5 0508 	rsbne	r5, r5, #8
 8000508:	f44f 5580 	moveq.w	r5, #4096	; 0x1000
 800050c:	1943      	addne	r3, r0, r5
 800050e:	f505 5580 	addne.w	r5, r5, #4096	; 0x1000
 8000512:	eb03 020b 	add.w	r2, r3, fp
 8000516:	4630      	mov	r0, r6
 8000518:	9301      	str	r3, [sp, #4]
 800051a:	0512      	lsls	r2, r2, #20
 800051c:	0d12      	lsrs	r2, r2, #20
 800051e:	1aad      	subs	r5, r5, r2
 8000520:	4629      	mov	r1, r5
 8000522:	f000 fef7 	bl	8001314 <_sbrk_r>
 8000526:	9b01      	ldr	r3, [sp, #4]
 8000528:	f1b0 3fff 	cmp.w	r0, #4294967295
 800052c:	f000 812c 	beq.w	8000788 <_malloc_r+0x560>
 8000530:	1ac1      	subs	r1, r0, r3
 8000532:	1949      	adds	r1, r1, r5
 8000534:	f041 0101 	orr.w	r1, r1, #1
 8000538:	f8da 2004 	ldr.w	r2, [sl, #4]
 800053c:	45b8      	cmp	r8, r7
 800053e:	f240 5b4c 	movw	fp, #1356	; 0x54c
 8000542:	60bb      	str	r3, [r7, #8]
 8000544:	442a      	add	r2, r5
 8000546:	f2c2 0b00 	movt	fp, #8192	; 0x2000
 800054a:	6059      	str	r1, [r3, #4]
 800054c:	f8ca 2004 	str.w	r2, [sl, #4]
 8000550:	d017      	beq.n	8000582 <_malloc_r+0x35a>
 8000552:	f1b9 0f0f 	cmp.w	r9, #15
 8000556:	f240 80e1 	bls.w	800071c <_malloc_r+0x4f4>
 800055a:	f1a9 030c 	sub.w	r3, r9, #12
 800055e:	f8d8 5004 	ldr.w	r5, [r8, #4]
 8000562:	f023 0307 	bic.w	r3, r3, #7
 8000566:	2005      	movs	r0, #5
 8000568:	eb08 0103 	add.w	r1, r8, r3
 800056c:	2b0f      	cmp	r3, #15
 800056e:	f005 0501 	and.w	r5, r5, #1
 8000572:	ea43 0505 	orr.w	r5, r3, r5
 8000576:	f8c8 5004 	str.w	r5, [r8, #4]
 800057a:	6048      	str	r0, [r1, #4]
 800057c:	6088      	str	r0, [r1, #8]
 800057e:	f200 80fb 	bhi.w	8000778 <_malloc_r+0x550>
 8000582:	f8da 102c 	ldr.w	r1, [sl, #44]	; 0x2c
 8000586:	f240 534c 	movw	r3, #1356	; 0x54c
 800058a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800058e:	428a      	cmp	r2, r1
 8000590:	f8da 1030 	ldr.w	r1, [sl, #48]	; 0x30
 8000594:	bf88      	it	hi
 8000596:	62da      	strhi	r2, [r3, #44]	; 0x2c
 8000598:	f240 534c 	movw	r3, #1356	; 0x54c
 800059c:	428a      	cmp	r2, r1
 800059e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80005a2:	f240 80a7 	bls.w	80006f4 <_malloc_r+0x4cc>
 80005a6:	f8d7 8008 	ldr.w	r8, [r7, #8]
 80005aa:	631a      	str	r2, [r3, #48]	; 0x30
 80005ac:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80005b0:	f023 0303 	bic.w	r3, r3, #3
 80005b4:	429c      	cmp	r4, r3
 80005b6:	ebc4 0203 	rsb	r2, r4, r3
 80005ba:	bf94      	ite	ls
 80005bc:	2300      	movls	r3, #0
 80005be:	2301      	movhi	r3, #1
 80005c0:	2a0f      	cmp	r2, #15
 80005c2:	bfd8      	it	le
 80005c4:	f043 0301 	orrle.w	r3, r3, #1
 80005c8:	b1b3      	cbz	r3, 80005f8 <_malloc_r+0x3d0>
 80005ca:	4630      	mov	r0, r6
 80005cc:	f04f 0800 	mov.w	r8, #0
 80005d0:	f000 fee0 	bl	8001394 <__malloc_unlock>
 80005d4:	e65e      	b.n	8000294 <_malloc_r+0x6c>
 80005d6:	189a      	adds	r2, r3, r2
 80005d8:	68d9      	ldr	r1, [r3, #12]
 80005da:	689c      	ldr	r4, [r3, #8]
 80005dc:	f103 0808 	add.w	r8, r3, #8
 80005e0:	6855      	ldr	r5, [r2, #4]
 80005e2:	4630      	mov	r0, r6
 80005e4:	f045 0301 	orr.w	r3, r5, #1
 80005e8:	60e1      	str	r1, [r4, #12]
 80005ea:	608c      	str	r4, [r1, #8]
 80005ec:	6053      	str	r3, [r2, #4]
 80005ee:	f000 fed1 	bl	8001394 <__malloc_unlock>
 80005f2:	e64f      	b.n	8000294 <_malloc_r+0x6c>
 80005f4:	200000fc 	.word	0x200000fc
 80005f8:	eb08 0304 	add.w	r3, r8, r4
 80005fc:	f042 0201 	orr.w	r2, r2, #1
 8000600:	f044 0401 	orr.w	r4, r4, #1
 8000604:	4630      	mov	r0, r6
 8000606:	f8c8 4004 	str.w	r4, [r8, #4]
 800060a:	f108 0808 	add.w	r8, r8, #8
 800060e:	605a      	str	r2, [r3, #4]
 8000610:	60bb      	str	r3, [r7, #8]
 8000612:	f000 febf 	bl	8001394 <__malloc_unlock>
 8000616:	e63d      	b.n	8000294 <_malloc_r+0x6c>
 8000618:	0a41      	lsrs	r1, r0, #9
 800061a:	2904      	cmp	r1, #4
 800061c:	bf9c      	itt	ls
 800061e:	ea4f 1e90 	movls.w	lr, r0, lsr #6
 8000622:	f10e 0e38 	addls.w	lr, lr, #56	; 0x38
 8000626:	d91d      	bls.n	8000664 <_malloc_r+0x43c>
 8000628:	2914      	cmp	r1, #20
 800062a:	bf98      	it	ls
 800062c:	f101 0e5b 	addls.w	lr, r1, #91	; 0x5b
 8000630:	d918      	bls.n	8000664 <_malloc_r+0x43c>
 8000632:	2954      	cmp	r1, #84	; 0x54
 8000634:	bf9c      	itt	ls
 8000636:	ea4f 3e10 	movls.w	lr, r0, lsr #12
 800063a:	f10e 0e6e 	addls.w	lr, lr, #110	; 0x6e
 800063e:	d911      	bls.n	8000664 <_malloc_r+0x43c>
 8000640:	f5b1 7faa 	cmp.w	r1, #340	; 0x154
 8000644:	bf9c      	itt	ls
 8000646:	ea4f 3ed0 	movls.w	lr, r0, lsr #15
 800064a:	f10e 0e77 	addls.w	lr, lr, #119	; 0x77
 800064e:	d909      	bls.n	8000664 <_malloc_r+0x43c>
 8000650:	f240 5e54 	movw	lr, #1364	; 0x554
 8000654:	4571      	cmp	r1, lr
 8000656:	bf96      	itet	ls
 8000658:	ea4f 4e90 	movls.w	lr, r0, lsr #18
 800065c:	f04f 0e7e 	movhi.w	lr, #126	; 0x7e
 8000660:	f10e 0e7c 	addls.w	lr, lr, #124	; 0x7c
 8000664:	eb07 08ce 	add.w	r8, r7, lr, lsl #3
 8000668:	f8d8 1008 	ldr.w	r1, [r8, #8]
 800066c:	4541      	cmp	r1, r8
 800066e:	d103      	bne.n	8000678 <_malloc_r+0x450>
 8000670:	e047      	b.n	8000702 <_malloc_r+0x4da>
 8000672:	6889      	ldr	r1, [r1, #8]
 8000674:	4588      	cmp	r8, r1
 8000676:	d005      	beq.n	8000684 <_malloc_r+0x45c>
 8000678:	f8d1 e004 	ldr.w	lr, [r1, #4]
 800067c:	f02e 0e03 	bic.w	lr, lr, #3
 8000680:	4570      	cmp	r0, lr
 8000682:	d3f6      	bcc.n	8000672 <_malloc_r+0x44a>
 8000684:	f8d1 e00c 	ldr.w	lr, [r1, #12]
 8000688:	f8c3 e00c 	str.w	lr, [r3, #12]
 800068c:	6099      	str	r1, [r3, #8]
 800068e:	6878      	ldr	r0, [r7, #4]
 8000690:	60cb      	str	r3, [r1, #12]
 8000692:	f8ce 3008 	str.w	r3, [lr, #8]
 8000696:	e65d      	b.n	8000354 <_malloc_r+0x12c>
 8000698:	191d      	adds	r5, r3, r4
 800069a:	f041 0701 	orr.w	r7, r1, #1
 800069e:	60d5      	str	r5, [r2, #12]
 80006a0:	f044 0401 	orr.w	r4, r4, #1
 80006a4:	6095      	str	r5, [r2, #8]
 80006a6:	4630      	mov	r0, r6
 80006a8:	605c      	str	r4, [r3, #4]
 80006aa:	f103 0808 	add.w	r8, r3, #8
 80006ae:	60ea      	str	r2, [r5, #12]
 80006b0:	60aa      	str	r2, [r5, #8]
 80006b2:	606f      	str	r7, [r5, #4]
 80006b4:	5069      	str	r1, [r5, r1]
 80006b6:	f000 fe6d 	bl	8001394 <__malloc_unlock>
 80006ba:	e5eb      	b.n	8000294 <_malloc_r+0x6c>
 80006bc:	f109 0901 	add.w	r9, r9, #1
 80006c0:	f019 0f03 	tst.w	r9, #3
 80006c4:	d02f      	beq.n	8000726 <_malloc_r+0x4fe>
 80006c6:	f108 0808 	add.w	r8, r8, #8
 80006ca:	e65b      	b.n	8000384 <_malloc_r+0x15c>
 80006cc:	f103 0208 	add.w	r2, r3, #8
 80006d0:	695b      	ldr	r3, [r3, #20]
 80006d2:	429a      	cmp	r2, r3
 80006d4:	bf08      	it	eq
 80006d6:	f10c 0c02 	addeq.w	ip, ip, #2
 80006da:	f43f ae10 	beq.w	80002fe <_malloc_r+0xd6>
 80006de:	e5c8      	b.n	8000272 <_malloc_r+0x4a>
 80006e0:	4680      	mov	r8, r0
 80006e2:	1843      	adds	r3, r0, r1
 80006e4:	68c2      	ldr	r2, [r0, #12]
 80006e6:	4630      	mov	r0, r6
 80006e8:	f858 1f08 	ldr.w	r1, [r8, #8]!
 80006ec:	e5ca      	b.n	8000284 <_malloc_r+0x5c>
 80006ee:	45b8      	cmp	r8, r7
 80006f0:	f43f aeed 	beq.w	80004ce <_malloc_r+0x2a6>
 80006f4:	f8d7 8008 	ldr.w	r8, [r7, #8]
 80006f8:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80006fc:	f023 0303 	bic.w	r3, r3, #3
 8000700:	e758      	b.n	80005b4 <_malloc_r+0x38c>
 8000702:	f04f 0901 	mov.w	r9, #1
 8000706:	f8d7 8004 	ldr.w	r8, [r7, #4]
 800070a:	ea4f 00ae 	mov.w	r0, lr, asr #2
 800070e:	468e      	mov	lr, r1
 8000710:	fa09 f000 	lsl.w	r0, r9, r0
 8000714:	ea48 0000 	orr.w	r0, r8, r0
 8000718:	6078      	str	r0, [r7, #4]
 800071a:	e7b5      	b.n	8000688 <_malloc_r+0x460>
 800071c:	4698      	mov	r8, r3
 800071e:	2201      	movs	r2, #1
 8000720:	605a      	str	r2, [r3, #4]
 8000722:	2300      	movs	r3, #0
 8000724:	e746      	b.n	80005b4 <_malloc_r+0x38c>
 8000726:	4651      	mov	r1, sl
 8000728:	f01c 0f03 	tst.w	ip, #3
 800072c:	460b      	mov	r3, r1
 800072e:	f10c 3cff 	add.w	ip, ip, #4294967295
 8000732:	d02c      	beq.n	800078e <_malloc_r+0x566>
 8000734:	f853 1908 	ldr.w	r1, [r3], #-8
 8000738:	4299      	cmp	r1, r3
 800073a:	d0f5      	beq.n	8000728 <_malloc_r+0x500>
 800073c:	687b      	ldr	r3, [r7, #4]
 800073e:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 8000742:	459e      	cmp	lr, r3
 8000744:	f63f ae8c 	bhi.w	8000460 <_malloc_r+0x238>
 8000748:	f1be 0f00 	cmp.w	lr, #0
 800074c:	f43f ae88 	beq.w	8000460 <_malloc_r+0x238>
 8000750:	ea1e 0f03 	tst.w	lr, r3
 8000754:	d020      	beq.n	8000798 <_malloc_r+0x570>
 8000756:	46cc      	mov	ip, r9
 8000758:	e610      	b.n	800037c <_malloc_r+0x154>
 800075a:	ea4f 5e01 	mov.w	lr, r1, lsl #20
 800075e:	ea4f 5e1e 	mov.w	lr, lr, lsr #20
 8000762:	f1be 0f00 	cmp.w	lr, #0
 8000766:	f47f aeba 	bne.w	80004de <_malloc_r+0x2b6>
 800076a:	68bb      	ldr	r3, [r7, #8]
 800076c:	eb0b 0109 	add.w	r1, fp, r9
 8000770:	f041 0101 	orr.w	r1, r1, #1
 8000774:	6059      	str	r1, [r3, #4]
 8000776:	e704      	b.n	8000582 <_malloc_r+0x35a>
 8000778:	4630      	mov	r0, r6
 800077a:	f108 0108 	add.w	r1, r8, #8
 800077e:	f000 f9ab 	bl	8000ad8 <_free_r>
 8000782:	f8db 2004 	ldr.w	r2, [fp, #4]
 8000786:	e6fc      	b.n	8000582 <_malloc_r+0x35a>
 8000788:	2101      	movs	r1, #1
 800078a:	2500      	movs	r5, #0
 800078c:	e6d4      	b.n	8000538 <_malloc_r+0x310>
 800078e:	687b      	ldr	r3, [r7, #4]
 8000790:	ea23 030e 	bic.w	r3, r3, lr
 8000794:	607b      	str	r3, [r7, #4]
 8000796:	e7d1      	b.n	800073c <_malloc_r+0x514>
 8000798:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 800079c:	f109 0904 	add.w	r9, r9, #4
 80007a0:	e7d6      	b.n	8000750 <_malloc_r+0x528>
 80007a2:	bf00      	nop

080007a4 <memset>:
 80007a4:	2a03      	cmp	r2, #3
 80007a6:	b2c9      	uxtb	r1, r1
 80007a8:	b470      	push	{r4, r5, r6}
 80007aa:	d808      	bhi.n	80007be <memset+0x1a>
 80007ac:	b12a      	cbz	r2, 80007ba <memset+0x16>
 80007ae:	4603      	mov	r3, r0
 80007b0:	1812      	adds	r2, r2, r0
 80007b2:	f803 1b01 	strb.w	r1, [r3], #1
 80007b6:	4293      	cmp	r3, r2
 80007b8:	d1fb      	bne.n	80007b2 <memset+0xe>
 80007ba:	bc70      	pop	{r4, r5, r6}
 80007bc:	4770      	bx	lr
 80007be:	1882      	adds	r2, r0, r2
 80007c0:	4604      	mov	r4, r0
 80007c2:	e001      	b.n	80007c8 <memset+0x24>
 80007c4:	f804 1b01 	strb.w	r1, [r4], #1
 80007c8:	f014 0f03 	tst.w	r4, #3
 80007cc:	d1fa      	bne.n	80007c4 <memset+0x20>
 80007ce:	f04f 3301 	mov.w	r3, #16843009	; 0x1010101
 80007d2:	fb03 f301 	mul.w	r3, r3, r1
 80007d6:	e01f      	b.n	8000818 <memset+0x74>
 80007d8:	f844 3c40 	str.w	r3, [r4, #-64]
 80007dc:	f844 3c3c 	str.w	r3, [r4, #-60]
 80007e0:	f844 3c38 	str.w	r3, [r4, #-56]
 80007e4:	f844 3c34 	str.w	r3, [r4, #-52]
 80007e8:	f844 3c30 	str.w	r3, [r4, #-48]
 80007ec:	f844 3c2c 	str.w	r3, [r4, #-44]
 80007f0:	f844 3c28 	str.w	r3, [r4, #-40]
 80007f4:	f844 3c24 	str.w	r3, [r4, #-36]
 80007f8:	f844 3c20 	str.w	r3, [r4, #-32]
 80007fc:	f844 3c1c 	str.w	r3, [r4, #-28]
 8000800:	f844 3c18 	str.w	r3, [r4, #-24]
 8000804:	f844 3c14 	str.w	r3, [r4, #-20]
 8000808:	f844 3c10 	str.w	r3, [r4, #-16]
 800080c:	f844 3c0c 	str.w	r3, [r4, #-12]
 8000810:	f844 3c08 	str.w	r3, [r4, #-8]
 8000814:	f844 3c04 	str.w	r3, [r4, #-4]
 8000818:	1b16      	subs	r6, r2, r4
 800081a:	4625      	mov	r5, r4
 800081c:	3440      	adds	r4, #64	; 0x40
 800081e:	2e3f      	cmp	r6, #63	; 0x3f
 8000820:	dcda      	bgt.n	80007d8 <memset+0x34>
 8000822:	462c      	mov	r4, r5
 8000824:	e007      	b.n	8000836 <memset+0x92>
 8000826:	f844 3c10 	str.w	r3, [r4, #-16]
 800082a:	f844 3c0c 	str.w	r3, [r4, #-12]
 800082e:	f844 3c08 	str.w	r3, [r4, #-8]
 8000832:	f844 3c04 	str.w	r3, [r4, #-4]
 8000836:	1b16      	subs	r6, r2, r4
 8000838:	4625      	mov	r5, r4
 800083a:	3410      	adds	r4, #16
 800083c:	2e0f      	cmp	r6, #15
 800083e:	dcf2      	bgt.n	8000826 <memset+0x82>
 8000840:	e001      	b.n	8000846 <memset+0xa2>
 8000842:	f845 3b04 	str.w	r3, [r5], #4
 8000846:	1b54      	subs	r4, r2, r5
 8000848:	2c03      	cmp	r4, #3
 800084a:	dcfa      	bgt.n	8000842 <memset+0x9e>
 800084c:	e001      	b.n	8000852 <memset+0xae>
 800084e:	f805 1b01 	strb.w	r1, [r5], #1
 8000852:	4295      	cmp	r5, r2
 8000854:	d3fb      	bcc.n	800084e <memset+0xaa>
 8000856:	e7b0      	b.n	80007ba <memset+0x16>

08000858 <strncpy>:
 8000858:	ea41 0300 	orr.w	r3, r1, r0
 800085c:	f013 0f03 	tst.w	r3, #3
 8000860:	460b      	mov	r3, r1
 8000862:	b470      	push	{r4, r5, r6}
 8000864:	bf14      	ite	ne
 8000866:	2400      	movne	r4, #0
 8000868:	2401      	moveq	r4, #1
 800086a:	2a03      	cmp	r2, #3
 800086c:	bf94      	ite	ls
 800086e:	2400      	movls	r4, #0
 8000870:	f004 0401 	andhi.w	r4, r4, #1
 8000874:	4605      	mov	r5, r0
 8000876:	b9d4      	cbnz	r4, 80008ae <strncpy+0x56>
 8000878:	b1ba      	cbz	r2, 80008aa <strncpy+0x52>
 800087a:	780e      	ldrb	r6, [r1, #0]
 800087c:	462b      	mov	r3, r5
 800087e:	3a01      	subs	r2, #1
 8000880:	f803 6b01 	strb.w	r6, [r3], #1
 8000884:	b156      	cbz	r6, 800089c <strncpy+0x44>
 8000886:	1cac      	adds	r4, r5, #2
 8000888:	b17a      	cbz	r2, 80008aa <strncpy+0x52>
 800088a:	f811 5f01 	ldrb.w	r5, [r1, #1]!
 800088e:	4623      	mov	r3, r4
 8000890:	3a01      	subs	r2, #1
 8000892:	f804 5c01 	strb.w	r5, [r4, #-1]
 8000896:	3401      	adds	r4, #1
 8000898:	2d00      	cmp	r5, #0
 800089a:	d1f5      	bne.n	8000888 <strncpy+0x30>
 800089c:	b12a      	cbz	r2, 80008aa <strncpy+0x52>
 800089e:	189a      	adds	r2, r3, r2
 80008a0:	2100      	movs	r1, #0
 80008a2:	f803 1b01 	strb.w	r1, [r3], #1
 80008a6:	4293      	cmp	r3, r2
 80008a8:	d1fb      	bne.n	80008a2 <strncpy+0x4a>
 80008aa:	bc70      	pop	{r4, r5, r6}
 80008ac:	4770      	bx	lr
 80008ae:	4619      	mov	r1, r3
 80008b0:	f853 4b04 	ldr.w	r4, [r3], #4
 80008b4:	f1a4 3601 	sub.w	r6, r4, #16843009	; 0x1010101
 80008b8:	ea26 0604 	bic.w	r6, r6, r4
 80008bc:	f016 3f80 	tst.w	r6, #2155905152	; 0x80808080
 80008c0:	d1da      	bne.n	8000878 <strncpy+0x20>
 80008c2:	3a04      	subs	r2, #4
 80008c4:	f845 4b04 	str.w	r4, [r5], #4
 80008c8:	2a03      	cmp	r2, #3
 80008ca:	4619      	mov	r1, r3
 80008cc:	d8ef      	bhi.n	80008ae <strncpy+0x56>
 80008ce:	e7d3      	b.n	8000878 <strncpy+0x20>

080008d0 <register_fini>:
 80008d0:	f240 0300 	movw	r3, #0
 80008d4:	f2c0 0300 	movt	r3, #0
 80008d8:	b12b      	cbz	r3, 80008e6 <register_fini+0x16>
 80008da:	f640 2001 	movw	r0, #2561	; 0xa01
 80008de:	f6c0 0000 	movt	r0, #2048	; 0x800
 80008e2:	f000 b887 	b.w	80009f4 <atexit>
 80008e6:	4770      	bx	lr

080008e8 <__call_exitprocs>:
 80008e8:	f242 5324 	movw	r3, #9508	; 0x2524
 80008ec:	f240 2219 	movw	r2, #537	; 0x219
 80008f0:	f6c0 0300 	movt	r3, #2048	; 0x800
 80008f4:	f6c0 0200 	movt	r2, #2048	; 0x800
 80008f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80008fc:	460f      	mov	r7, r1
 80008fe:	681b      	ldr	r3, [r3, #0]
 8000900:	b085      	sub	sp, #20
 8000902:	9003      	str	r0, [sp, #12]
 8000904:	9302      	str	r3, [sp, #8]
 8000906:	9201      	str	r2, [sp, #4]
 8000908:	9b02      	ldr	r3, [sp, #8]
 800090a:	f8d3 9048 	ldr.w	r9, [r3, #72]	; 0x48
 800090e:	f1b9 0f00 	cmp.w	r9, #0
 8000912:	d01c      	beq.n	800094e <__call_exitprocs+0x66>
 8000914:	f103 0a48 	add.w	sl, r3, #72	; 0x48
 8000918:	f8d9 5004 	ldr.w	r5, [r9, #4]
 800091c:	f8d9 8088 	ldr.w	r8, [r9, #136]	; 0x88
 8000920:	1e6c      	subs	r4, r5, #1
 8000922:	d411      	bmi.n	8000948 <__call_exitprocs+0x60>
 8000924:	1cae      	adds	r6, r5, #2
 8000926:	eb08 0585 	add.w	r5, r8, r5, lsl #2
 800092a:	eb09 0686 	add.w	r6, r9, r6, lsl #2
 800092e:	b18f      	cbz	r7, 8000954 <__call_exitprocs+0x6c>
 8000930:	f1b8 0f00 	cmp.w	r8, #0
 8000934:	d002      	beq.n	800093c <__call_exitprocs+0x54>
 8000936:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 8000938:	42bb      	cmp	r3, r7
 800093a:	d00b      	beq.n	8000954 <__call_exitprocs+0x6c>
 800093c:	3c01      	subs	r4, #1
 800093e:	3d04      	subs	r5, #4
 8000940:	3e04      	subs	r6, #4
 8000942:	f1b4 3fff 	cmp.w	r4, #4294967295
 8000946:	d1f2      	bne.n	800092e <__call_exitprocs+0x46>
 8000948:	9a01      	ldr	r2, [sp, #4]
 800094a:	2a00      	cmp	r2, #0
 800094c:	d134      	bne.n	80009b8 <__call_exitprocs+0xd0>
 800094e:	b005      	add	sp, #20
 8000950:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000954:	f8d9 2004 	ldr.w	r2, [r9, #4]
 8000958:	f856 3c04 	ldr.w	r3, [r6, #-4]
 800095c:	3a01      	subs	r2, #1
 800095e:	42a2      	cmp	r2, r4
 8000960:	bf08      	it	eq
 8000962:	f8c9 4004 	streq.w	r4, [r9, #4]
 8000966:	d002      	beq.n	800096e <__call_exitprocs+0x86>
 8000968:	2000      	movs	r0, #0
 800096a:	f846 0c04 	str.w	r0, [r6, #-4]
 800096e:	2b00      	cmp	r3, #0
 8000970:	d0e4      	beq.n	800093c <__call_exitprocs+0x54>
 8000972:	f8d9 b004 	ldr.w	fp, [r9, #4]
 8000976:	f1b8 0f00 	cmp.w	r8, #0
 800097a:	d017      	beq.n	80009ac <__call_exitprocs+0xc4>
 800097c:	2001      	movs	r0, #1
 800097e:	f8d8 1100 	ldr.w	r1, [r8, #256]	; 0x100
 8000982:	fa10 f204 	lsls.w	r2, r0, r4
 8000986:	420a      	tst	r2, r1
 8000988:	d010      	beq.n	80009ac <__call_exitprocs+0xc4>
 800098a:	f8d8 1104 	ldr.w	r1, [r8, #260]	; 0x104
 800098e:	420a      	tst	r2, r1
 8000990:	d10e      	bne.n	80009b0 <__call_exitprocs+0xc8>
 8000992:	9803      	ldr	r0, [sp, #12]
 8000994:	f855 1c04 	ldr.w	r1, [r5, #-4]
 8000998:	4798      	blx	r3
 800099a:	f8d9 3004 	ldr.w	r3, [r9, #4]
 800099e:	455b      	cmp	r3, fp
 80009a0:	d1b2      	bne.n	8000908 <__call_exitprocs+0x20>
 80009a2:	f8da 3000 	ldr.w	r3, [sl]
 80009a6:	454b      	cmp	r3, r9
 80009a8:	d0c8      	beq.n	800093c <__call_exitprocs+0x54>
 80009aa:	e7ad      	b.n	8000908 <__call_exitprocs+0x20>
 80009ac:	4798      	blx	r3
 80009ae:	e7f4      	b.n	800099a <__call_exitprocs+0xb2>
 80009b0:	f855 0c04 	ldr.w	r0, [r5, #-4]
 80009b4:	4798      	blx	r3
 80009b6:	e7f0      	b.n	800099a <__call_exitprocs+0xb2>
 80009b8:	f8d9 3004 	ldr.w	r3, [r9, #4]
 80009bc:	b13b      	cbz	r3, 80009ce <__call_exitprocs+0xe6>
 80009be:	f8d9 3000 	ldr.w	r3, [r9]
 80009c2:	46ca      	mov	sl, r9
 80009c4:	4699      	mov	r9, r3
 80009c6:	f1b9 0f00 	cmp.w	r9, #0
 80009ca:	d1a5      	bne.n	8000918 <__call_exitprocs+0x30>
 80009cc:	e7bf      	b.n	800094e <__call_exitprocs+0x66>
 80009ce:	f8d9 3000 	ldr.w	r3, [r9]
 80009d2:	2b00      	cmp	r3, #0
 80009d4:	d0f5      	beq.n	80009c2 <__call_exitprocs+0xda>
 80009d6:	f8ca 3000 	str.w	r3, [sl]
 80009da:	f1b8 0f00 	cmp.w	r8, #0
 80009de:	d002      	beq.n	80009e6 <__call_exitprocs+0xfe>
 80009e0:	4640      	mov	r0, r8
 80009e2:	f7ff fc19 	bl	8000218 <free>
 80009e6:	4648      	mov	r0, r9
 80009e8:	f7ff fc16 	bl	8000218 <free>
 80009ec:	f8da 9000 	ldr.w	r9, [sl]
 80009f0:	e7e9      	b.n	80009c6 <__call_exitprocs+0xde>
 80009f2:	bf00      	nop

080009f4 <atexit>:
 80009f4:	4601      	mov	r1, r0
 80009f6:	2000      	movs	r0, #0
 80009f8:	4602      	mov	r2, r0
 80009fa:	4603      	mov	r3, r0
 80009fc:	f000 b938 	b.w	8000c70 <__register_exitproc>

08000a00 <__libc_fini_array>:
 8000a00:	b570      	push	{r4, r5, r6, lr}
 8000a02:	f242 54b0 	movw	r4, #9648	; 0x25b0
 8000a06:	f242 55ac 	movw	r5, #9644	; 0x25ac
 8000a0a:	f6c0 0400 	movt	r4, #2048	; 0x800
 8000a0e:	f6c0 0500 	movt	r5, #2048	; 0x800
 8000a12:	1b64      	subs	r4, r4, r5
 8000a14:	10a4      	asrs	r4, r4, #2
 8000a16:	d006      	beq.n	8000a26 <__libc_fini_array+0x26>
 8000a18:	eb05 0584 	add.w	r5, r5, r4, lsl #2
 8000a1c:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 8000a20:	4798      	blx	r3
 8000a22:	3c01      	subs	r4, #1
 8000a24:	d1fa      	bne.n	8000a1c <__libc_fini_array+0x1c>
 8000a26:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8000a2a:	f001 bdb5 	b.w	8002598 <_fini>
 8000a2e:	bf00      	nop

08000a30 <_malloc_trim_r>:
 8000a30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000a32:	f240 04f4 	movw	r4, #244	; 0xf4
 8000a36:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8000a3a:	460f      	mov	r7, r1
 8000a3c:	4605      	mov	r5, r0
 8000a3e:	f000 fc9f 	bl	8001380 <__malloc_lock>
 8000a42:	68a3      	ldr	r3, [r4, #8]
 8000a44:	685e      	ldr	r6, [r3, #4]
 8000a46:	f026 0603 	bic.w	r6, r6, #3
 8000a4a:	f506 637e 	add.w	r3, r6, #4064	; 0xfe0
 8000a4e:	330f      	adds	r3, #15
 8000a50:	1bdf      	subs	r7, r3, r7
 8000a52:	0b3f      	lsrs	r7, r7, #12
 8000a54:	3f01      	subs	r7, #1
 8000a56:	033f      	lsls	r7, r7, #12
 8000a58:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
 8000a5c:	db07      	blt.n	8000a6e <_malloc_trim_r+0x3e>
 8000a5e:	2100      	movs	r1, #0
 8000a60:	4628      	mov	r0, r5
 8000a62:	f000 fc57 	bl	8001314 <_sbrk_r>
 8000a66:	68a3      	ldr	r3, [r4, #8]
 8000a68:	199b      	adds	r3, r3, r6
 8000a6a:	4298      	cmp	r0, r3
 8000a6c:	d004      	beq.n	8000a78 <_malloc_trim_r+0x48>
 8000a6e:	4628      	mov	r0, r5
 8000a70:	f000 fc90 	bl	8001394 <__malloc_unlock>
 8000a74:	2000      	movs	r0, #0
 8000a76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000a78:	4279      	negs	r1, r7
 8000a7a:	4628      	mov	r0, r5
 8000a7c:	f000 fc4a 	bl	8001314 <_sbrk_r>
 8000a80:	f1b0 3fff 	cmp.w	r0, #4294967295
 8000a84:	d010      	beq.n	8000aa8 <_malloc_trim_r+0x78>
 8000a86:	f240 5350 	movw	r3, #1360	; 0x550
 8000a8a:	68a1      	ldr	r1, [r4, #8]
 8000a8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000a90:	1bf6      	subs	r6, r6, r7
 8000a92:	4628      	mov	r0, r5
 8000a94:	f046 0601 	orr.w	r6, r6, #1
 8000a98:	681a      	ldr	r2, [r3, #0]
 8000a9a:	604e      	str	r6, [r1, #4]
 8000a9c:	1bd7      	subs	r7, r2, r7
 8000a9e:	601f      	str	r7, [r3, #0]
 8000aa0:	f000 fc78 	bl	8001394 <__malloc_unlock>
 8000aa4:	2001      	movs	r0, #1
 8000aa6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000aa8:	2100      	movs	r1, #0
 8000aaa:	4628      	mov	r0, r5
 8000aac:	f000 fc32 	bl	8001314 <_sbrk_r>
 8000ab0:	68a3      	ldr	r3, [r4, #8]
 8000ab2:	1ac2      	subs	r2, r0, r3
 8000ab4:	2a0f      	cmp	r2, #15
 8000ab6:	ddda      	ble.n	8000a6e <_malloc_trim_r+0x3e>
 8000ab8:	f240 44fc 	movw	r4, #1276	; 0x4fc
 8000abc:	f240 5150 	movw	r1, #1360	; 0x550
 8000ac0:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8000ac4:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8000ac8:	f042 0201 	orr.w	r2, r2, #1
 8000acc:	605a      	str	r2, [r3, #4]
 8000ace:	6823      	ldr	r3, [r4, #0]
 8000ad0:	1ac0      	subs	r0, r0, r3
 8000ad2:	6008      	str	r0, [r1, #0]
 8000ad4:	e7cb      	b.n	8000a6e <_malloc_trim_r+0x3e>
 8000ad6:	bf00      	nop

08000ad8 <_free_r>:
 8000ad8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000adc:	460d      	mov	r5, r1
 8000ade:	4604      	mov	r4, r0
 8000ae0:	2900      	cmp	r1, #0
 8000ae2:	d058      	beq.n	8000b96 <_free_r+0xbe>
 8000ae4:	f000 fc4c 	bl	8001380 <__malloc_lock>
 8000ae8:	f1a5 0208 	sub.w	r2, r5, #8
 8000aec:	f240 00f4 	movw	r0, #244	; 0xf4
 8000af0:	6856      	ldr	r6, [r2, #4]
 8000af2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000af6:	f026 0301 	bic.w	r3, r6, #1
 8000afa:	f8d0 c008 	ldr.w	ip, [r0, #8]
 8000afe:	18d1      	adds	r1, r2, r3
 8000b00:	458c      	cmp	ip, r1
 8000b02:	684f      	ldr	r7, [r1, #4]
 8000b04:	f027 0703 	bic.w	r7, r7, #3
 8000b08:	d065      	beq.n	8000bd6 <_free_r+0xfe>
 8000b0a:	f016 0601 	ands.w	r6, r6, #1
 8000b0e:	604f      	str	r7, [r1, #4]
 8000b10:	d031      	beq.n	8000b76 <_free_r+0x9e>
 8000b12:	2600      	movs	r6, #0
 8000b14:	19cd      	adds	r5, r1, r7
 8000b16:	686d      	ldr	r5, [r5, #4]
 8000b18:	f015 0f01 	tst.w	r5, #1
 8000b1c:	d106      	bne.n	8000b2c <_free_r+0x54>
 8000b1e:	19db      	adds	r3, r3, r7
 8000b20:	2e00      	cmp	r6, #0
 8000b22:	d04b      	beq.n	8000bbc <_free_r+0xe4>
 8000b24:	688d      	ldr	r5, [r1, #8]
 8000b26:	68c9      	ldr	r1, [r1, #12]
 8000b28:	60e9      	str	r1, [r5, #12]
 8000b2a:	608d      	str	r5, [r1, #8]
 8000b2c:	f043 0101 	orr.w	r1, r3, #1
 8000b30:	50d3      	str	r3, [r2, r3]
 8000b32:	6051      	str	r1, [r2, #4]
 8000b34:	b9d6      	cbnz	r6, 8000b6c <_free_r+0x94>
 8000b36:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8000b3a:	d32e      	bcc.n	8000b9a <_free_r+0xc2>
 8000b3c:	0a59      	lsrs	r1, r3, #9
 8000b3e:	2904      	cmp	r1, #4
 8000b40:	d86b      	bhi.n	8000c1a <_free_r+0x142>
 8000b42:	099e      	lsrs	r6, r3, #6
 8000b44:	3638      	adds	r6, #56	; 0x38
 8000b46:	00f5      	lsls	r5, r6, #3
 8000b48:	1945      	adds	r5, r0, r5
 8000b4a:	68a9      	ldr	r1, [r5, #8]
 8000b4c:	42a9      	cmp	r1, r5
 8000b4e:	d103      	bne.n	8000b58 <_free_r+0x80>
 8000b50:	e069      	b.n	8000c26 <_free_r+0x14e>
 8000b52:	6889      	ldr	r1, [r1, #8]
 8000b54:	428d      	cmp	r5, r1
 8000b56:	d004      	beq.n	8000b62 <_free_r+0x8a>
 8000b58:	6848      	ldr	r0, [r1, #4]
 8000b5a:	f020 0003 	bic.w	r0, r0, #3
 8000b5e:	4283      	cmp	r3, r0
 8000b60:	d3f7      	bcc.n	8000b52 <_free_r+0x7a>
 8000b62:	68cb      	ldr	r3, [r1, #12]
 8000b64:	60d3      	str	r3, [r2, #12]
 8000b66:	6091      	str	r1, [r2, #8]
 8000b68:	60ca      	str	r2, [r1, #12]
 8000b6a:	609a      	str	r2, [r3, #8]
 8000b6c:	4620      	mov	r0, r4
 8000b6e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8000b72:	f000 bc0f 	b.w	8001394 <__malloc_unlock>
 8000b76:	f855 5c08 	ldr.w	r5, [r5, #-8]
 8000b7a:	f100 0c08 	add.w	ip, r0, #8
 8000b7e:	1b52      	subs	r2, r2, r5
 8000b80:	195b      	adds	r3, r3, r5
 8000b82:	6895      	ldr	r5, [r2, #8]
 8000b84:	4565      	cmp	r5, ip
 8000b86:	d046      	beq.n	8000c16 <_free_r+0x13e>
 8000b88:	f8d2 c00c 	ldr.w	ip, [r2, #12]
 8000b8c:	f8c5 c00c 	str.w	ip, [r5, #12]
 8000b90:	f8cc 5008 	str.w	r5, [ip, #8]
 8000b94:	e7be      	b.n	8000b14 <_free_r+0x3c>
 8000b96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000b9a:	08db      	lsrs	r3, r3, #3
 8000b9c:	2501      	movs	r5, #1
 8000b9e:	6846      	ldr	r6, [r0, #4]
 8000ba0:	eb00 01c3 	add.w	r1, r0, r3, lsl #3
 8000ba4:	109b      	asrs	r3, r3, #2
 8000ba6:	fa15 f303 	lsls.w	r3, r5, r3
 8000baa:	60d1      	str	r1, [r2, #12]
 8000bac:	688d      	ldr	r5, [r1, #8]
 8000bae:	ea46 0303 	orr.w	r3, r6, r3
 8000bb2:	6043      	str	r3, [r0, #4]
 8000bb4:	6095      	str	r5, [r2, #8]
 8000bb6:	60ea      	str	r2, [r5, #12]
 8000bb8:	608a      	str	r2, [r1, #8]
 8000bba:	e7d7      	b.n	8000b6c <_free_r+0x94>
 8000bbc:	688d      	ldr	r5, [r1, #8]
 8000bbe:	4f2b      	ldr	r7, [pc, #172]	; (8000c6c <_free_r+0x194>)
 8000bc0:	42bd      	cmp	r5, r7
 8000bc2:	d1b0      	bne.n	8000b26 <_free_r+0x4e>
 8000bc4:	60ea      	str	r2, [r5, #12]
 8000bc6:	f043 0101 	orr.w	r1, r3, #1
 8000bca:	60aa      	str	r2, [r5, #8]
 8000bcc:	60d5      	str	r5, [r2, #12]
 8000bce:	6095      	str	r5, [r2, #8]
 8000bd0:	6051      	str	r1, [r2, #4]
 8000bd2:	50d3      	str	r3, [r2, r3]
 8000bd4:	e7ca      	b.n	8000b6c <_free_r+0x94>
 8000bd6:	f016 0f01 	tst.w	r6, #1
 8000bda:	443b      	add	r3, r7
 8000bdc:	d107      	bne.n	8000bee <_free_r+0x116>
 8000bde:	f855 1c08 	ldr.w	r1, [r5, #-8]
 8000be2:	1a52      	subs	r2, r2, r1
 8000be4:	185b      	adds	r3, r3, r1
 8000be6:	6895      	ldr	r5, [r2, #8]
 8000be8:	68d1      	ldr	r1, [r2, #12]
 8000bea:	60e9      	str	r1, [r5, #12]
 8000bec:	608d      	str	r5, [r1, #8]
 8000bee:	f240 5100 	movw	r1, #1280	; 0x500
 8000bf2:	f043 0501 	orr.w	r5, r3, #1
 8000bf6:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8000bfa:	6055      	str	r5, [r2, #4]
 8000bfc:	6082      	str	r2, [r0, #8]
 8000bfe:	680a      	ldr	r2, [r1, #0]
 8000c00:	4293      	cmp	r3, r2
 8000c02:	d3b3      	bcc.n	8000b6c <_free_r+0x94>
 8000c04:	f240 534c 	movw	r3, #1356	; 0x54c
 8000c08:	4620      	mov	r0, r4
 8000c0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c0e:	6819      	ldr	r1, [r3, #0]
 8000c10:	f7ff ff0e 	bl	8000a30 <_malloc_trim_r>
 8000c14:	e7aa      	b.n	8000b6c <_free_r+0x94>
 8000c16:	2601      	movs	r6, #1
 8000c18:	e77c      	b.n	8000b14 <_free_r+0x3c>
 8000c1a:	2914      	cmp	r1, #20
 8000c1c:	d80c      	bhi.n	8000c38 <_free_r+0x160>
 8000c1e:	f101 065b 	add.w	r6, r1, #91	; 0x5b
 8000c22:	00f5      	lsls	r5, r6, #3
 8000c24:	e790      	b.n	8000b48 <_free_r+0x70>
 8000c26:	2501      	movs	r5, #1
 8000c28:	6847      	ldr	r7, [r0, #4]
 8000c2a:	10b6      	asrs	r6, r6, #2
 8000c2c:	460b      	mov	r3, r1
 8000c2e:	40b5      	lsls	r5, r6
 8000c30:	ea47 0505 	orr.w	r5, r7, r5
 8000c34:	6045      	str	r5, [r0, #4]
 8000c36:	e795      	b.n	8000b64 <_free_r+0x8c>
 8000c38:	2954      	cmp	r1, #84	; 0x54
 8000c3a:	d803      	bhi.n	8000c44 <_free_r+0x16c>
 8000c3c:	0b1e      	lsrs	r6, r3, #12
 8000c3e:	366e      	adds	r6, #110	; 0x6e
 8000c40:	00f5      	lsls	r5, r6, #3
 8000c42:	e781      	b.n	8000b48 <_free_r+0x70>
 8000c44:	f5b1 7faa 	cmp.w	r1, #340	; 0x154
 8000c48:	d803      	bhi.n	8000c52 <_free_r+0x17a>
 8000c4a:	0bde      	lsrs	r6, r3, #15
 8000c4c:	3677      	adds	r6, #119	; 0x77
 8000c4e:	00f5      	lsls	r5, r6, #3
 8000c50:	e77a      	b.n	8000b48 <_free_r+0x70>
 8000c52:	f240 5554 	movw	r5, #1364	; 0x554
 8000c56:	42a9      	cmp	r1, r5
 8000c58:	d803      	bhi.n	8000c62 <_free_r+0x18a>
 8000c5a:	0c9e      	lsrs	r6, r3, #18
 8000c5c:	367c      	adds	r6, #124	; 0x7c
 8000c5e:	00f5      	lsls	r5, r6, #3
 8000c60:	e772      	b.n	8000b48 <_free_r+0x70>
 8000c62:	f44f 757c 	mov.w	r5, #1008	; 0x3f0
 8000c66:	267e      	movs	r6, #126	; 0x7e
 8000c68:	e76e      	b.n	8000b48 <_free_r+0x70>
 8000c6a:	bf00      	nop
 8000c6c:	200000fc 	.word	0x200000fc

08000c70 <__register_exitproc>:
 8000c70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000c74:	f242 5424 	movw	r4, #9508	; 0x2524
 8000c78:	f6c0 0400 	movt	r4, #2048	; 0x800
 8000c7c:	b084      	sub	sp, #16
 8000c7e:	4605      	mov	r5, r0
 8000c80:	6826      	ldr	r6, [r4, #0]
 8000c82:	6cb4      	ldr	r4, [r6, #72]	; 0x48
 8000c84:	2c00      	cmp	r4, #0
 8000c86:	d029      	beq.n	8000cdc <__register_exitproc+0x6c>
 8000c88:	6860      	ldr	r0, [r4, #4]
 8000c8a:	281f      	cmp	r0, #31
 8000c8c:	dc2a      	bgt.n	8000ce4 <__register_exitproc+0x74>
 8000c8e:	b1dd      	cbz	r5, 8000cc8 <__register_exitproc+0x58>
 8000c90:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
 8000c94:	2800      	cmp	r0, #0
 8000c96:	d02d      	beq.n	8000cf4 <__register_exitproc+0x84>
 8000c98:	f8d0 8100 	ldr.w	r8, [r0, #256]	; 0x100
 8000c9c:	6866      	ldr	r6, [r4, #4]
 8000c9e:	2701      	movs	r7, #1
 8000ca0:	f106 0c20 	add.w	ip, r6, #32
 8000ca4:	40b7      	lsls	r7, r6
 8000ca6:	2d02      	cmp	r5, #2
 8000ca8:	f840 2026 	str.w	r2, [r0, r6, lsl #2]
 8000cac:	f840 302c 	str.w	r3, [r0, ip, lsl #2]
 8000cb0:	ea48 0207 	orr.w	r2, r8, r7
 8000cb4:	bf08      	it	eq
 8000cb6:	f8d0 3104 	ldreq.w	r3, [r0, #260]	; 0x104
 8000cba:	f8c0 2100 	str.w	r2, [r0, #256]	; 0x100
 8000cbe:	bf04      	itt	eq
 8000cc0:	431f      	orreq	r7, r3
 8000cc2:	f8c0 7104 	streq.w	r7, [r0, #260]	; 0x104
 8000cc6:	e000      	b.n	8000cca <__register_exitproc+0x5a>
 8000cc8:	6866      	ldr	r6, [r4, #4]
 8000cca:	1cb3      	adds	r3, r6, #2
 8000ccc:	2000      	movs	r0, #0
 8000cce:	3601      	adds	r6, #1
 8000cd0:	6066      	str	r6, [r4, #4]
 8000cd2:	f844 1023 	str.w	r1, [r4, r3, lsl #2]
 8000cd6:	b004      	add	sp, #16
 8000cd8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000cdc:	f106 044c 	add.w	r4, r6, #76	; 0x4c
 8000ce0:	64b4      	str	r4, [r6, #72]	; 0x48
 8000ce2:	e7d1      	b.n	8000c88 <__register_exitproc+0x18>
 8000ce4:	f240 2009 	movw	r0, #521	; 0x209
 8000ce8:	f6c0 0000 	movt	r0, #2048	; 0x800
 8000cec:	b9e8      	cbnz	r0, 8000d2a <__register_exitproc+0xba>
 8000cee:	f04f 30ff 	mov.w	r0, #4294967295
 8000cf2:	e7f0      	b.n	8000cd6 <__register_exitproc+0x66>
 8000cf4:	f240 2009 	movw	r0, #521	; 0x209
 8000cf8:	f6c0 0000 	movt	r0, #2048	; 0x800
 8000cfc:	2800      	cmp	r0, #0
 8000cfe:	d0f6      	beq.n	8000cee <__register_exitproc+0x7e>
 8000d00:	f44f 7084 	mov.w	r0, #264	; 0x108
 8000d04:	9103      	str	r1, [sp, #12]
 8000d06:	9202      	str	r2, [sp, #8]
 8000d08:	9301      	str	r3, [sp, #4]
 8000d0a:	f7ff fa7d 	bl	8000208 <malloc>
 8000d0e:	9903      	ldr	r1, [sp, #12]
 8000d10:	9a02      	ldr	r2, [sp, #8]
 8000d12:	9b01      	ldr	r3, [sp, #4]
 8000d14:	2800      	cmp	r0, #0
 8000d16:	d0ea      	beq.n	8000cee <__register_exitproc+0x7e>
 8000d18:	2600      	movs	r6, #0
 8000d1a:	f8c0 6100 	str.w	r6, [r0, #256]	; 0x100
 8000d1e:	f8c0 6104 	str.w	r6, [r0, #260]	; 0x104
 8000d22:	46b0      	mov	r8, r6
 8000d24:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
 8000d28:	e7b8      	b.n	8000c9c <__register_exitproc+0x2c>
 8000d2a:	208c      	movs	r0, #140	; 0x8c
 8000d2c:	9103      	str	r1, [sp, #12]
 8000d2e:	9202      	str	r2, [sp, #8]
 8000d30:	9301      	str	r3, [sp, #4]
 8000d32:	f7ff fa69 	bl	8000208 <malloc>
 8000d36:	9903      	ldr	r1, [sp, #12]
 8000d38:	9a02      	ldr	r2, [sp, #8]
 8000d3a:	9b01      	ldr	r3, [sp, #4]
 8000d3c:	4604      	mov	r4, r0
 8000d3e:	2800      	cmp	r0, #0
 8000d40:	d0d5      	beq.n	8000cee <__register_exitproc+0x7e>
 8000d42:	6cb0      	ldr	r0, [r6, #72]	; 0x48
 8000d44:	2700      	movs	r7, #0
 8000d46:	6067      	str	r7, [r4, #4]
 8000d48:	6020      	str	r0, [r4, #0]
 8000d4a:	64b4      	str	r4, [r6, #72]	; 0x48
 8000d4c:	2d00      	cmp	r5, #0
 8000d4e:	d19f      	bne.n	8000c90 <__register_exitproc+0x20>
 8000d50:	e7ba      	b.n	8000cc8 <__register_exitproc+0x58>
 8000d52:	bf00      	nop

08000d54 <rb_getc>:
 * \param   rb    pointer to ringbuffer struct
 * \param   data  pointer to data byte
 * \return  number of bytes read (0 if buffer was empty)
 */
static inline int rb_getc(struct ringbuf *rb, char *data)
{
 8000d54:	b580      	push	{r7, lr}
 8000d56:	b082      	sub	sp, #8
 8000d58:	af00      	add	r7, sp, #0
 8000d5a:	6078      	str	r0, [r7, #4]
 8000d5c:	6039      	str	r1, [r7, #0]
    if (!rb->len)
 8000d5e:	687b      	ldr	r3, [r7, #4]
 8000d60:	68db      	ldr	r3, [r3, #12]
 8000d62:	2b00      	cmp	r3, #0
 8000d64:	d102      	bne.n	8000d6c <rb_getc+0x18>
        return 0;
 8000d66:	f04f 0300 	mov.w	r3, #0
 8000d6a:	e025      	b.n	8000db8 <rb_getc+0x64>

    vPortEnterCritical();
 8000d6c:	f000 ffd4 	bl	8001d18 <vPortEnterCritical>

    *data = rb->buf[rb->pos++];
 8000d70:	687b      	ldr	r3, [r7, #4]
 8000d72:	6819      	ldr	r1, [r3, #0]
 8000d74:	687b      	ldr	r3, [r7, #4]
 8000d76:	689b      	ldr	r3, [r3, #8]
 8000d78:	461a      	mov	r2, r3
 8000d7a:	188a      	adds	r2, r1, r2
 8000d7c:	7811      	ldrb	r1, [r2, #0]
 8000d7e:	683a      	ldr	r2, [r7, #0]
 8000d80:	7011      	strb	r1, [r2, #0]
 8000d82:	f103 0201 	add.w	r2, r3, #1
 8000d86:	687b      	ldr	r3, [r7, #4]
 8000d88:	609a      	str	r2, [r3, #8]
	if (rb->pos >= rb->bufsize)
 8000d8a:	687b      	ldr	r3, [r7, #4]
 8000d8c:	689a      	ldr	r2, [r3, #8]
 8000d8e:	687b      	ldr	r3, [r7, #4]
 8000d90:	685b      	ldr	r3, [r3, #4]
 8000d92:	429a      	cmp	r2, r3
 8000d94:	db06      	blt.n	8000da4 <rb_getc+0x50>
		rb->pos -= rb->bufsize;
 8000d96:	687b      	ldr	r3, [r7, #4]
 8000d98:	689a      	ldr	r2, [r3, #8]
 8000d9a:	687b      	ldr	r3, [r7, #4]
 8000d9c:	685b      	ldr	r3, [r3, #4]
 8000d9e:	1ad2      	subs	r2, r2, r3
 8000da0:	687b      	ldr	r3, [r7, #4]
 8000da2:	609a      	str	r2, [r3, #8]
	rb->len--;
 8000da4:	687b      	ldr	r3, [r7, #4]
 8000da6:	68db      	ldr	r3, [r3, #12]
 8000da8:	f103 32ff 	add.w	r2, r3, #4294967295
 8000dac:	687b      	ldr	r3, [r7, #4]
 8000dae:	60da      	str	r2, [r3, #12]

    vPortExitCritical();
 8000db0:	f000 ffc4 	bl	8001d3c <vPortExitCritical>
    return 1;
 8000db4:	f04f 0301 	mov.w	r3, #1
}
 8000db8:	4618      	mov	r0, r3
 8000dba:	f107 0708 	add.w	r7, r7, #8
 8000dbe:	46bd      	mov	sp, r7
 8000dc0:	bd80      	pop	{r7, pc}
 8000dc2:	bf00      	nop

08000dc4 <rb_putc>:
 * \param   rb    pointer to ringbuffer struct
 * \param   data  pointer to data byte
 * \return  number of bytes written (0 if buffer was full)
 */
static inline int rb_putc(struct ringbuf *rb, const char data)
{
 8000dc4:	b580      	push	{r7, lr}
 8000dc6:	b084      	sub	sp, #16
 8000dc8:	af00      	add	r7, sp, #0
 8000dca:	6078      	str	r0, [r7, #4]
 8000dcc:	460b      	mov	r3, r1
 8000dce:	70fb      	strb	r3, [r7, #3]
    if (rb->len >= rb->bufsize)
 8000dd0:	687b      	ldr	r3, [r7, #4]
 8000dd2:	68da      	ldr	r2, [r3, #12]
 8000dd4:	687b      	ldr	r3, [r7, #4]
 8000dd6:	685b      	ldr	r3, [r3, #4]
 8000dd8:	429a      	cmp	r2, r3
 8000dda:	db02      	blt.n	8000de2 <rb_putc+0x1e>
        return 0;
 8000ddc:	f04f 0300 	mov.w	r3, #0
 8000de0:	e021      	b.n	8000e26 <rb_putc+0x62>

    vPortEnterCritical();
 8000de2:	f000 ff99 	bl	8001d18 <vPortEnterCritical>

	int i = rb->pos + rb->len;
 8000de6:	687b      	ldr	r3, [r7, #4]
 8000de8:	689a      	ldr	r2, [r3, #8]
 8000dea:	687b      	ldr	r3, [r7, #4]
 8000dec:	68db      	ldr	r3, [r3, #12]
 8000dee:	18d3      	adds	r3, r2, r3
 8000df0:	60fb      	str	r3, [r7, #12]
	if (i >= rb->bufsize)
 8000df2:	687b      	ldr	r3, [r7, #4]
 8000df4:	685a      	ldr	r2, [r3, #4]
 8000df6:	68fb      	ldr	r3, [r7, #12]
 8000df8:	429a      	cmp	r2, r3
 8000dfa:	dc04      	bgt.n	8000e06 <rb_putc+0x42>
		i -= rb->bufsize;
 8000dfc:	687b      	ldr	r3, [r7, #4]
 8000dfe:	685b      	ldr	r3, [r3, #4]
 8000e00:	68fa      	ldr	r2, [r7, #12]
 8000e02:	1ad3      	subs	r3, r2, r3
 8000e04:	60fb      	str	r3, [r7, #12]

	rb->buf[i] = data;
 8000e06:	687b      	ldr	r3, [r7, #4]
 8000e08:	681a      	ldr	r2, [r3, #0]
 8000e0a:	68fb      	ldr	r3, [r7, #12]
 8000e0c:	18d3      	adds	r3, r2, r3
 8000e0e:	78fa      	ldrb	r2, [r7, #3]
 8000e10:	701a      	strb	r2, [r3, #0]
	rb->len++;
 8000e12:	687b      	ldr	r3, [r7, #4]
 8000e14:	68db      	ldr	r3, [r3, #12]
 8000e16:	f103 0201 	add.w	r2, r3, #1
 8000e1a:	687b      	ldr	r3, [r7, #4]
 8000e1c:	60da      	str	r2, [r3, #12]

    vPortExitCritical();
 8000e1e:	f000 ff8d 	bl	8001d3c <vPortExitCritical>
    return 1;
 8000e22:	f04f 0301 	mov.w	r3, #1
}
 8000e26:	4618      	mov	r0, r3
 8000e28:	f107 0710 	add.w	r7, r7, #16
 8000e2c:	46bd      	mov	sp, r7
 8000e2e:	bd80      	pop	{r7, pc}

08000e30 <USART1_IRQHandler>:
    uint32_t    tx_bytes;
} uart_stats;


void USART1_IRQHandler(void)
{
 8000e30:	b580      	push	{r7, lr}
 8000e32:	b082      	sub	sp, #8
 8000e34:	af00      	add	r7, sp, #0
    if (USART1->SR & USART_SR_RXNE) {
 8000e36:	4b22      	ldr	r3, [pc, #136]	; (8000ec0 <USART1_IRQHandler+0x90>)
 8000e38:	881b      	ldrh	r3, [r3, #0]
 8000e3a:	b29b      	uxth	r3, r3
 8000e3c:	f003 0320 	and.w	r3, r3, #32
 8000e40:	2b00      	cmp	r3, #0
 8000e42:	d017      	beq.n	8000e74 <USART1_IRQHandler+0x44>
        if (!rb_putc(&rx_buf, USART1->DR))
 8000e44:	4b1e      	ldr	r3, [pc, #120]	; (8000ec0 <USART1_IRQHandler+0x90>)
 8000e46:	889b      	ldrh	r3, [r3, #4]
 8000e48:	b29b      	uxth	r3, r3
 8000e4a:	b2db      	uxtb	r3, r3
 8000e4c:	481d      	ldr	r0, [pc, #116]	; (8000ec4 <USART1_IRQHandler+0x94>)
 8000e4e:	4619      	mov	r1, r3
 8000e50:	f7ff ffb8 	bl	8000dc4 <rb_putc>
 8000e54:	4603      	mov	r3, r0
 8000e56:	2b00      	cmp	r3, #0
 8000e58:	d106      	bne.n	8000e68 <USART1_IRQHandler+0x38>
            uart_stats.rx_overrun++;
 8000e5a:	4b1b      	ldr	r3, [pc, #108]	; (8000ec8 <USART1_IRQHandler+0x98>)
 8000e5c:	681b      	ldr	r3, [r3, #0]
 8000e5e:	f103 0201 	add.w	r2, r3, #1
 8000e62:	4b19      	ldr	r3, [pc, #100]	; (8000ec8 <USART1_IRQHandler+0x98>)
 8000e64:	601a      	str	r2, [r3, #0]
 8000e66:	e005      	b.n	8000e74 <USART1_IRQHandler+0x44>
        else
            uart_stats.rx_bytes++;
 8000e68:	4b17      	ldr	r3, [pc, #92]	; (8000ec8 <USART1_IRQHandler+0x98>)
 8000e6a:	685b      	ldr	r3, [r3, #4]
 8000e6c:	f103 0201 	add.w	r2, r3, #1
 8000e70:	4b15      	ldr	r3, [pc, #84]	; (8000ec8 <USART1_IRQHandler+0x98>)
 8000e72:	605a      	str	r2, [r3, #4]
    }

    if (USART1->SR & USART_SR_TXE) {
 8000e74:	4b12      	ldr	r3, [pc, #72]	; (8000ec0 <USART1_IRQHandler+0x90>)
 8000e76:	881b      	ldrh	r3, [r3, #0]
 8000e78:	b29b      	uxth	r3, r3
 8000e7a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8000e7e:	2b00      	cmp	r3, #0
 8000e80:	d01a      	beq.n	8000eb8 <USART1_IRQHandler+0x88>
        char c;
        if (rb_getc(&tx_buf, &c)) {
 8000e82:	f107 0307 	add.w	r3, r7, #7
 8000e86:	4811      	ldr	r0, [pc, #68]	; (8000ecc <USART1_IRQHandler+0x9c>)
 8000e88:	4619      	mov	r1, r3
 8000e8a:	f7ff ff63 	bl	8000d54 <rb_getc>
 8000e8e:	4603      	mov	r3, r0
 8000e90:	2b00      	cmp	r3, #0
 8000e92:	d003      	beq.n	8000e9c <USART1_IRQHandler+0x6c>
            // send a queued byte
            //
            USART1->DR = c;
 8000e94:	4b0a      	ldr	r3, [pc, #40]	; (8000ec0 <USART1_IRQHandler+0x90>)
 8000e96:	79fa      	ldrb	r2, [r7, #7]
 8000e98:	809a      	strh	r2, [r3, #4]
 8000e9a:	e007      	b.n	8000eac <USART1_IRQHandler+0x7c>
        }
        else {
            // nothing to send, disable interrupt
            //
            USART1->CR1 &= ~USART_CR1_TXEIE;
 8000e9c:	4b08      	ldr	r3, [pc, #32]	; (8000ec0 <USART1_IRQHandler+0x90>)
 8000e9e:	4a08      	ldr	r2, [pc, #32]	; (8000ec0 <USART1_IRQHandler+0x90>)
 8000ea0:	8992      	ldrh	r2, [r2, #12]
 8000ea2:	b292      	uxth	r2, r2
 8000ea4:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8000ea8:	b292      	uxth	r2, r2
 8000eaa:	819a      	strh	r2, [r3, #12]
        }
        uart_stats.tx_bytes++;
 8000eac:	4b06      	ldr	r3, [pc, #24]	; (8000ec8 <USART1_IRQHandler+0x98>)
 8000eae:	689b      	ldr	r3, [r3, #8]
 8000eb0:	f103 0201 	add.w	r2, r3, #1
 8000eb4:	4b04      	ldr	r3, [pc, #16]	; (8000ec8 <USART1_IRQHandler+0x98>)
 8000eb6:	609a      	str	r2, [r3, #8]
    }
}
 8000eb8:	f107 0708 	add.w	r7, r7, #8
 8000ebc:	46bd      	mov	sp, r7
 8000ebe:	bd80      	pop	{r7, pc}
 8000ec0:	40011000 	.word	0x40011000
 8000ec4:	20000504 	.word	0x20000504
 8000ec8:	20000680 	.word	0x20000680
 8000ecc:	20000514 	.word	0x20000514

08000ed0 <get_us_time>:
 *   this function must be called at least
 *   once every 65ms to work correctly.
 *
 */
uint64_t get_us_time()
{
 8000ed0:	b580      	push	{r7, lr}
 8000ed2:	b082      	sub	sp, #8
 8000ed4:	af00      	add	r7, sp, #0
    static uint16_t t0;
    static uint64_t tickcount;

    vPortEnterCritical();
 8000ed6:	f000 ff1f 	bl	8001d18 <vPortEnterCritical>

    int t = TIM7->CNT;
 8000eda:	4b16      	ldr	r3, [pc, #88]	; (8000f34 <get_us_time+0x64>)
 8000edc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000ede:	607b      	str	r3, [r7, #4]
    if (t < t0)
 8000ee0:	4b15      	ldr	r3, [pc, #84]	; (8000f38 <get_us_time+0x68>)
 8000ee2:	881b      	ldrh	r3, [r3, #0]
 8000ee4:	461a      	mov	r2, r3
 8000ee6:	687b      	ldr	r3, [r7, #4]
 8000ee8:	429a      	cmp	r2, r3
 8000eea:	dd03      	ble.n	8000ef4 <get_us_time+0x24>
        t += 0x10000;
 8000eec:	687b      	ldr	r3, [r7, #4]
 8000eee:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 8000ef2:	607b      	str	r3, [r7, #4]

    tickcount += t - t0;
 8000ef4:	4b10      	ldr	r3, [pc, #64]	; (8000f38 <get_us_time+0x68>)
 8000ef6:	881b      	ldrh	r3, [r3, #0]
 8000ef8:	687a      	ldr	r2, [r7, #4]
 8000efa:	1ad3      	subs	r3, r2, r3
 8000efc:	4618      	mov	r0, r3
 8000efe:	ea4f 71e3 	mov.w	r1, r3, asr #31
 8000f02:	4b0e      	ldr	r3, [pc, #56]	; (8000f3c <get_us_time+0x6c>)
 8000f04:	e9d3 2300 	ldrd	r2, r3, [r3]
 8000f08:	1812      	adds	r2, r2, r0
 8000f0a:	eb43 0301 	adc.w	r3, r3, r1
 8000f0e:	490b      	ldr	r1, [pc, #44]	; (8000f3c <get_us_time+0x6c>)
 8000f10:	e9c1 2300 	strd	r2, r3, [r1]
    t0 = t;
 8000f14:	687b      	ldr	r3, [r7, #4]
 8000f16:	b29a      	uxth	r2, r3
 8000f18:	4b07      	ldr	r3, [pc, #28]	; (8000f38 <get_us_time+0x68>)
 8000f1a:	801a      	strh	r2, [r3, #0]

    vPortExitCritical();
 8000f1c:	f000 ff0e 	bl	8001d3c <vPortExitCritical>

    return tickcount;
 8000f20:	4b06      	ldr	r3, [pc, #24]	; (8000f3c <get_us_time+0x6c>)
 8000f22:	e9d3 2300 	ldrd	r2, r3, [r3]
}
 8000f26:	4610      	mov	r0, r2
 8000f28:	4619      	mov	r1, r3
 8000f2a:	f107 0708 	add.w	r7, r7, #8
 8000f2e:	46bd      	mov	sp, r7
 8000f30:	bd80      	pop	{r7, pc}
 8000f32:	bf00      	nop
 8000f34:	40001400 	.word	0x40001400
 8000f38:	2000068c 	.word	0x2000068c
 8000f3c:	20000690 	.word	0x20000690

08000f40 <init_us_timer>:
/**
 * Set up TIM7 as a 16bit, microsecond-timer.
 *
 */
void init_us_timer()
{
 8000f40:	b580      	push	{r7, lr}
 8000f42:	b084      	sub	sp, #16
 8000f44:	af00      	add	r7, sp, #0
    RCC_ClocksTypeDef RCC_Clocks;
    RCC_GetClocksFreq(&RCC_Clocks);
 8000f46:	463b      	mov	r3, r7
 8000f48:	4618      	mov	r0, r3
 8000f4a:	f001 f86f 	bl	800202c <RCC_GetClocksFreq>

    RCC->APB1ENR |= RCC_APB1Periph_TIM7;
 8000f4e:	4b0f      	ldr	r3, [pc, #60]	; (8000f8c <init_us_timer+0x4c>)
 8000f50:	4a0e      	ldr	r2, [pc, #56]	; (8000f8c <init_us_timer+0x4c>)
 8000f52:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8000f54:	f042 0220 	orr.w	r2, r2, #32
 8000f58:	641a      	str	r2, [r3, #64]	; 0x40
    TIM7->PSC = (RCC_Clocks.PCLK2_Frequency / 1000000) - 1;
 8000f5a:	4b0d      	ldr	r3, [pc, #52]	; (8000f90 <init_us_timer+0x50>)
 8000f5c:	68f9      	ldr	r1, [r7, #12]
 8000f5e:	4a0d      	ldr	r2, [pc, #52]	; (8000f94 <init_us_timer+0x54>)
 8000f60:	fba2 0201 	umull	r0, r2, r2, r1
 8000f64:	ea4f 4292 	mov.w	r2, r2, lsr #18
 8000f68:	b292      	uxth	r2, r2
 8000f6a:	f102 32ff 	add.w	r2, r2, #4294967295
 8000f6e:	b292      	uxth	r2, r2
 8000f70:	851a      	strh	r2, [r3, #40]	; 0x28
    TIM7->ARR = 0xFFFF;
 8000f72:	4b07      	ldr	r3, [pc, #28]	; (8000f90 <init_us_timer+0x50>)
 8000f74:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8000f78:	62da      	str	r2, [r3, #44]	; 0x2c
    TIM7->CR1 = TIM_CR1_CEN;
 8000f7a:	4b05      	ldr	r3, [pc, #20]	; (8000f90 <init_us_timer+0x50>)
 8000f7c:	f04f 0201 	mov.w	r2, #1
 8000f80:	801a      	strh	r2, [r3, #0]
}
 8000f82:	f107 0710 	add.w	r7, r7, #16
 8000f86:	46bd      	mov	sp, r7
 8000f88:	bd80      	pop	{r7, pc}
 8000f8a:	bf00      	nop
 8000f8c:	40023800 	.word	0x40023800
 8000f90:	40001400 	.word	0x40001400
 8000f94:	431bde83 	.word	0x431bde83

08000f98 <UsartTask>:
#include <stdlib.h>

//Task For Sending Data Via USART
static void UsartTask(void *pvParameters)

{
 8000f98:	b580      	push	{r7, lr}
 8000f9a:	b084      	sub	sp, #16
 8000f9c:	af00      	add	r7, sp, #0
 8000f9e:	6078      	str	r0, [r7, #4]

	//Variable to store received data	
	uint32_t Data;
	
	//Wait for character
	while(USART_GetFlagStatus(USART2, USART_FLAG_RXNE) == RESET) {
 8000fa0:	e00a      	b.n	8000fb8 <UsartTask+0x20>
                if (USART_GetFlagStatus(USART2, (USART_FLAG_ORE | USART_FLAG_NE | USART_FLAG_FE | USART_FLAG_PE)))
 8000fa2:	4814      	ldr	r0, [pc, #80]	; (8000ff4 <UsartTask+0x5c>)
 8000fa4:	f04f 010f 	mov.w	r1, #15
 8000fa8:	f001 fa5c 	bl	8002464 <USART_GetFlagStatus>
 8000fac:	4603      	mov	r3, r0
 8000fae:	2b00      	cmp	r3, #0
 8000fb0:	d002      	beq.n	8000fb8 <UsartTask+0x20>
		USART_ReceiveData(USART2); // Clear Error
 8000fb2:	4810      	ldr	r0, [pc, #64]	; (8000ff4 <UsartTask+0x5c>)
 8000fb4:	f001 fa44 	bl	8002440 <USART_ReceiveData>

	//Variable to store received data	
	uint32_t Data;
	
	//Wait for character
	while(USART_GetFlagStatus(USART2, USART_FLAG_RXNE) == RESET) {
 8000fb8:	480e      	ldr	r0, [pc, #56]	; (8000ff4 <UsartTask+0x5c>)
 8000fba:	f04f 0120 	mov.w	r1, #32
 8000fbe:	f001 fa51 	bl	8002464 <USART_GetFlagStatus>
 8000fc2:	4603      	mov	r3, r0
 8000fc4:	2b00      	cmp	r3, #0
 8000fc6:	d0ec      	beq.n	8000fa2 <UsartTask+0xa>
                if (USART_GetFlagStatus(USART2, (USART_FLAG_ORE | USART_FLAG_NE | USART_FLAG_FE | USART_FLAG_PE)))
		USART_ReceiveData(USART2); // Clear Error
	}

	//Collect the caracter
	Data = USART_ReceiveData(USART2);
 8000fc8:	480a      	ldr	r0, [pc, #40]	; (8000ff4 <UsartTask+0x5c>)
 8000fca:	f001 fa39 	bl	8002440 <USART_ReceiveData>
 8000fce:	4603      	mov	r3, r0
 8000fd0:	60fb      	str	r3, [r7, #12]

	//Wait till the flag resets
	while(USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET);
 8000fd2:	bf00      	nop
 8000fd4:	4807      	ldr	r0, [pc, #28]	; (8000ff4 <UsartTask+0x5c>)
 8000fd6:	f04f 0180 	mov.w	r1, #128	; 0x80
 8000fda:	f001 fa43 	bl	8002464 <USART_GetFlagStatus>
 8000fde:	4603      	mov	r3, r0
 8000fe0:	2b00      	cmp	r3, #0
 8000fe2:	d0f7      	beq.n	8000fd4 <UsartTask+0x3c>

	//Send the data
	USART_SendData(USART2, Data); // Echo Char
 8000fe4:	68fb      	ldr	r3, [r7, #12]
 8000fe6:	b29b      	uxth	r3, r3
 8000fe8:	4802      	ldr	r0, [pc, #8]	; (8000ff4 <UsartTask+0x5c>)
 8000fea:	4619      	mov	r1, r3
 8000fec:	f001 fa14 	bl	8002418 <USART_SendData>
}
 8000ff0:	bf00      	nop

	//Variable to store received data	
	uint32_t Data;
	
	//Wait for character
	while(USART_GetFlagStatus(USART2, USART_FLAG_RXNE) == RESET) {
 8000ff2:	e7e1      	b.n	8000fb8 <UsartTask+0x20>
 8000ff4:	40004400 	.word	0x40004400

08000ff8 <initx>:

}


//Initialize GPIO and USART2
void initx(void){
 8000ff8:	b580      	push	{r7, lr}
 8000ffa:	b086      	sub	sp, #24
 8000ffc:	af00      	add	r7, sp, #0

	//Enable GPIO Clocks For USART2
        RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 8000ffe:	f04f 0001 	mov.w	r0, #1
 8001002:	f04f 0101 	mov.w	r1, #1
 8001006:	f001 f8cf 	bl	80021a8 <RCC_AHB1PeriphClockCmd>

	//Enable Clocks for USART2
        RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);	
 800100a:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 800100e:	f04f 0101 	mov.w	r1, #1
 8001012:	f001 f8eb 	bl	80021ec <RCC_APB1PeriphClockCmd>

	//Structure With Data For USART Configuration
	USART_InitTypeDef USART_InitStructure;

	//GPIO Configuration
  	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;
 8001016:	f04f 030c 	mov.w	r3, #12
 800101a:	613b      	str	r3, [r7, #16]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 800101c:	f04f 0302 	mov.w	r3, #2
 8001020:	753b      	strb	r3, [r7, #20]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8001022:	f04f 0300 	mov.w	r3, #0
 8001026:	75bb      	strb	r3, [r7, #22]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8001028:	f04f 0300 	mov.w	r3, #0
 800102c:	75fb      	strb	r3, [r7, #23]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800102e:	f04f 0302 	mov.w	r3, #2
 8001032:	757b      	strb	r3, [r7, #21]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8001034:	f107 0310 	add.w	r3, r7, #16
 8001038:	4826      	ldr	r0, [pc, #152]	; (80010d4 <initx+0xdc>)
 800103a:	4619      	mov	r1, r3
 800103c:	f000 fefc 	bl	8001e38 <GPIO_Init>

	//Connect USART pins to AF
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_USART2);
 8001040:	4824      	ldr	r0, [pc, #144]	; (80010d4 <initx+0xdc>)
 8001042:	f04f 0102 	mov.w	r1, #2
 8001046:	f04f 0207 	mov.w	r2, #7
 800104a:	f000 ff99 	bl	8001f80 <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_USART2);
 800104e:	4821      	ldr	r0, [pc, #132]	; (80010d4 <initx+0xdc>)
 8001050:	f04f 0103 	mov.w	r1, #3
 8001054:	f04f 0207 	mov.w	r2, #7
 8001058:	f000 ff92 	bl	8001f80 <GPIO_PinAFConfig>

	//Initialize LED
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
 800105c:	f04f 0008 	mov.w	r0, #8
 8001060:	f04f 0101 	mov.w	r1, #1
 8001064:	f001 f8a0 	bl	80021a8 <RCC_AHB1PeriphClockCmd>
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13| GPIO_Pin_14| GPIO_Pin_15;
 8001068:	f44f 4370 	mov.w	r3, #61440	; 0xf000
 800106c:	613b      	str	r3, [r7, #16]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 800106e:	f04f 0301 	mov.w	r3, #1
 8001072:	753b      	strb	r3, [r7, #20]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8001074:	f04f 0300 	mov.w	r3, #0
 8001078:	75bb      	strb	r3, [r7, #22]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 800107a:	f04f 0303 	mov.w	r3, #3
 800107e:	757b      	strb	r3, [r7, #21]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8001080:	f04f 0300 	mov.w	r3, #0
 8001084:	75fb      	strb	r3, [r7, #23]
	GPIO_Init(GPIOD, &GPIO_InitStructure);
 8001086:	f107 0310 	add.w	r3, r7, #16
 800108a:	4813      	ldr	r0, [pc, #76]	; (80010d8 <initx+0xe0>)
 800108c:	4619      	mov	r1, r3
 800108e:	f000 fed3 	bl	8001e38 <GPIO_Init>

	//USART Parameters
	USART_InitStructure.USART_BaudRate = 38400;
 8001092:	f44f 4316 	mov.w	r3, #38400	; 0x9600
 8001096:	603b      	str	r3, [r7, #0]
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 8001098:	f04f 0300 	mov.w	r3, #0
 800109c:	80bb      	strh	r3, [r7, #4]
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
 800109e:	f04f 0300 	mov.w	r3, #0
 80010a2:	80fb      	strh	r3, [r7, #6]
	USART_InitStructure.USART_Parity = USART_Parity_No ;
 80010a4:	f04f 0300 	mov.w	r3, #0
 80010a8:	813b      	strh	r3, [r7, #8]
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
 80010aa:	f04f 0300 	mov.w	r3, #0
 80010ae:	81bb      	strh	r3, [r7, #12]
        USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx ;
 80010b0:	f04f 030c 	mov.w	r3, #12
 80010b4:	817b      	strh	r3, [r7, #10]

	//Configuring And Enabling USART2
	USART_Init(USART2, &USART_InitStructure);
 80010b6:	463b      	mov	r3, r7
 80010b8:	4808      	ldr	r0, [pc, #32]	; (80010dc <initx+0xe4>)
 80010ba:	4619      	mov	r1, r3
 80010bc:	f001 f8b8 	bl	8002230 <USART_Init>
	USART_Cmd(USART2, ENABLE);
 80010c0:	4806      	ldr	r0, [pc, #24]	; (80010dc <initx+0xe4>)
 80010c2:	f04f 0101 	mov.w	r1, #1
 80010c6:	f001 f987 	bl	80023d8 <USART_Cmd>

}
 80010ca:	f107 0718 	add.w	r7, r7, #24
 80010ce:	46bd      	mov	sp, r7
 80010d0:	bd80      	pop	{r7, pc}
 80010d2:	bf00      	nop
 80010d4:	40020000 	.word	0x40020000
 80010d8:	40020c00 	.word	0x40020c00
 80010dc:	40004400 	.word	0x40004400

080010e0 <main>:


//Main Function
int main(void)
{
 80010e0:	b580      	push	{r7, lr}
 80010e2:	b084      	sub	sp, #16
 80010e4:	af04      	add	r7, sp, #16

	//Call initx(); To Initialize USART & GPIO
	initx();
 80010e6:	f7ff ff87 	bl	8000ff8 <initx>

	//Create Task For USART
	xTaskCreate(UsartTask, (signed char*)"UsartTask", 128, NULL, tskIDLE_PRIORITY+1, NULL);
 80010ea:	4b0e      	ldr	r3, [pc, #56]	; (8001124 <main+0x44>)
 80010ec:	f04f 0201 	mov.w	r2, #1
 80010f0:	9200      	str	r2, [sp, #0]
 80010f2:	f04f 0200 	mov.w	r2, #0
 80010f6:	9201      	str	r2, [sp, #4]
 80010f8:	f04f 0200 	mov.w	r2, #0
 80010fc:	9202      	str	r2, [sp, #8]
 80010fe:	f04f 0200 	mov.w	r2, #0
 8001102:	9203      	str	r2, [sp, #12]
 8001104:	4808      	ldr	r0, [pc, #32]	; (8001128 <main+0x48>)
 8001106:	4619      	mov	r1, r3
 8001108:	f04f 0280 	mov.w	r2, #128	; 0x80
 800110c:	f04f 0300 	mov.w	r3, #0
 8001110:	f000 f94a 	bl	80013a8 <xTaskGenericCreate>

	//Call Scheduler
	vTaskStartScheduler();
 8001114:	f000 f9f8 	bl	8001508 <vTaskStartScheduler>
 8001118:	f04f 0300 	mov.w	r3, #0

}
 800111c:	4618      	mov	r0, r3
 800111e:	46bd      	mov	sp, r7
 8001120:	bd80      	pop	{r7, pc}
 8001122:	bf00      	nop
 8001124:	080024a4 	.word	0x080024a4
 8001128:	08000f99 	.word	0x08000f99

0800112c <Reset_Handler>:
 800112c:	2100      	movs	r1, #0
 800112e:	e003      	b.n	8001138 <LoopCopyDataInit>

08001130 <CopyDataInit>:
 8001130:	4b0e      	ldr	r3, [pc, #56]	; (800116c <LoopFillZerobss+0x20>)
 8001132:	585b      	ldr	r3, [r3, r1]
 8001134:	5043      	str	r3, [r0, r1]
 8001136:	3104      	adds	r1, #4

08001138 <LoopCopyDataInit>:
 8001138:	480d      	ldr	r0, [pc, #52]	; (8001170 <LoopFillZerobss+0x24>)
 800113a:	4b0e      	ldr	r3, [pc, #56]	; (8001174 <LoopFillZerobss+0x28>)
 800113c:	1842      	adds	r2, r0, r1
 800113e:	429a      	cmp	r2, r3
 8001140:	d3f6      	bcc.n	8001130 <CopyDataInit>
 8001142:	4a0d      	ldr	r2, [pc, #52]	; (8001178 <LoopFillZerobss+0x2c>)
 8001144:	e002      	b.n	800114c <LoopFillZerobss>

08001146 <FillZerobss>:
 8001146:	2300      	movs	r3, #0
 8001148:	f842 3b04 	str.w	r3, [r2], #4

0800114c <LoopFillZerobss>:
 800114c:	4b0b      	ldr	r3, [pc, #44]	; (800117c <LoopFillZerobss+0x30>)
 800114e:	429a      	cmp	r2, r3
 8001150:	d3f9      	bcc.n	8001146 <FillZerobss>
 8001152:	480b      	ldr	r0, [pc, #44]	; (8001180 <LoopFillZerobss+0x34>)
 8001154:	6801      	ldr	r1, [r0, #0]
 8001156:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800115a:	6001      	str	r1, [r0, #0]
 800115c:	f000 f814 	bl	8001188 <SystemInit>
 8001160:	f7ff f82a 	bl	80001b8 <__libc_init_array>
 8001164:	f7ff ffbc 	bl	80010e0 <main>
 8001168:	4770      	bx	lr
 800116a:	0000      	.short	0x0000
 800116c:	080025b0 	.word	0x080025b0
 8001170:	20000000 	.word	0x20000000
 8001174:	20000544 	.word	0x20000544
 8001178:	20000548 	.word	0x20000548
 800117c:	200007a4 	.word	0x200007a4
 8001180:	e000ed88 	.word	0xe000ed88

08001184 <ADC_IRQHandler>:
 8001184:	e7fe      	b.n	8001184 <ADC_IRQHandler>
 8001186:	0000      	movs	r0, r0

08001188 <SystemInit>:
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8001188:	b580      	push	{r7, lr}
 800118a:	af00      	add	r7, sp, #0
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800118c:	4b12      	ldr	r3, [pc, #72]	; (80011d8 <SystemInit+0x50>)
 800118e:	4a12      	ldr	r2, [pc, #72]	; (80011d8 <SystemInit+0x50>)
 8001190:	6812      	ldr	r2, [r2, #0]
 8001192:	f042 0201 	orr.w	r2, r2, #1
 8001196:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8001198:	4b0f      	ldr	r3, [pc, #60]	; (80011d8 <SystemInit+0x50>)
 800119a:	f04f 0200 	mov.w	r2, #0
 800119e:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80011a0:	4a0d      	ldr	r2, [pc, #52]	; (80011d8 <SystemInit+0x50>)
 80011a2:	4b0d      	ldr	r3, [pc, #52]	; (80011d8 <SystemInit+0x50>)
 80011a4:	681b      	ldr	r3, [r3, #0]
 80011a6:	f023 7384 	bic.w	r3, r3, #17301504	; 0x1080000
 80011aa:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80011ae:	6013      	str	r3, [r2, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 80011b0:	4b09      	ldr	r3, [pc, #36]	; (80011d8 <SystemInit+0x50>)
 80011b2:	4a0a      	ldr	r2, [pc, #40]	; (80011dc <SystemInit+0x54>)
 80011b4:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80011b6:	4b08      	ldr	r3, [pc, #32]	; (80011d8 <SystemInit+0x50>)
 80011b8:	4a07      	ldr	r2, [pc, #28]	; (80011d8 <SystemInit+0x50>)
 80011ba:	6812      	ldr	r2, [r2, #0]
 80011bc:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80011c0:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 80011c2:	4b05      	ldr	r3, [pc, #20]	; (80011d8 <SystemInit+0x50>)
 80011c4:	f04f 0200 	mov.w	r2, #0
 80011c8:	60da      	str	r2, [r3, #12]
  SystemInit_ExtMemCtl(); 
#endif /* DATA_IN_ExtSRAM */
         
  /* Configure the System clock source, PLL Multiplier and Divider factors, 
     AHB/APBx prescalers and Flash settings ----------------------------------*/
  SetSysClock();
 80011ca:	f000 f80b 	bl	80011e4 <SetSysClock>

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 80011ce:	4b04      	ldr	r3, [pc, #16]	; (80011e0 <SystemInit+0x58>)
 80011d0:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 80011d4:	609a      	str	r2, [r3, #8]
#endif
}
 80011d6:	bd80      	pop	{r7, pc}
 80011d8:	40023800 	.word	0x40023800
 80011dc:	24003010 	.word	0x24003010
 80011e0:	e000ed00 	.word	0xe000ed00

080011e4 <SetSysClock>:
  *         is reset to the default reset state (done in SystemInit() function).   
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
 80011e4:	b480      	push	{r7}
 80011e6:	b083      	sub	sp, #12
 80011e8:	af00      	add	r7, sp, #0
/******************************************************************************/
/*            PLL (clocked by HSE) used as System clock source                */
/******************************************************************************/
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 80011ea:	f04f 0300 	mov.w	r3, #0
 80011ee:	607b      	str	r3, [r7, #4]
 80011f0:	f04f 0300 	mov.w	r3, #0
 80011f4:	603b      	str	r3, [r7, #0]
  
  /* Enable HSE */
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 80011f6:	4b42      	ldr	r3, [pc, #264]	; (8001300 <SetSysClock+0x11c>)
 80011f8:	4a41      	ldr	r2, [pc, #260]	; (8001300 <SetSysClock+0x11c>)
 80011fa:	6812      	ldr	r2, [r2, #0]
 80011fc:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8001200:	601a      	str	r2, [r3, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 8001202:	4b3f      	ldr	r3, [pc, #252]	; (8001300 <SetSysClock+0x11c>)
 8001204:	681b      	ldr	r3, [r3, #0]
 8001206:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800120a:	603b      	str	r3, [r7, #0]
    StartUpCounter++;
 800120c:	687b      	ldr	r3, [r7, #4]
 800120e:	f103 0301 	add.w	r3, r3, #1
 8001212:	607b      	str	r3, [r7, #4]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 8001214:	683b      	ldr	r3, [r7, #0]
 8001216:	2b00      	cmp	r3, #0
 8001218:	d103      	bne.n	8001222 <SetSysClock+0x3e>
 800121a:	687b      	ldr	r3, [r7, #4]
 800121c:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8001220:	d1ef      	bne.n	8001202 <SetSysClock+0x1e>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 8001222:	4b37      	ldr	r3, [pc, #220]	; (8001300 <SetSysClock+0x11c>)
 8001224:	681b      	ldr	r3, [r3, #0]
 8001226:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800122a:	2b00      	cmp	r3, #0
 800122c:	d003      	beq.n	8001236 <SetSysClock+0x52>
  {
    HSEStatus = (uint32_t)0x01;
 800122e:	f04f 0301 	mov.w	r3, #1
 8001232:	603b      	str	r3, [r7, #0]
 8001234:	e002      	b.n	800123c <SetSysClock+0x58>
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 8001236:	f04f 0300 	mov.w	r3, #0
 800123a:	603b      	str	r3, [r7, #0]
  }

  if (HSEStatus == (uint32_t)0x01)
 800123c:	683b      	ldr	r3, [r7, #0]
 800123e:	2b01      	cmp	r3, #1
 8001240:	d142      	bne.n	80012c8 <SetSysClock+0xe4>
  {
    /* Enable high performance mode, System frequency up to 168 MHz */
    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 8001242:	4b2f      	ldr	r3, [pc, #188]	; (8001300 <SetSysClock+0x11c>)
 8001244:	4a2e      	ldr	r2, [pc, #184]	; (8001300 <SetSysClock+0x11c>)
 8001246:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8001248:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800124c:	641a      	str	r2, [r3, #64]	; 0x40
    PWR->CR |= PWR_CR_PMODE;  
 800124e:	4b2d      	ldr	r3, [pc, #180]	; (8001304 <SetSysClock+0x120>)
 8001250:	4a2c      	ldr	r2, [pc, #176]	; (8001304 <SetSysClock+0x120>)
 8001252:	6812      	ldr	r2, [r2, #0]
 8001254:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001258:	601a      	str	r2, [r3, #0]

    /* HCLK = SYSCLK / 1*/
    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 800125a:	4b29      	ldr	r3, [pc, #164]	; (8001300 <SetSysClock+0x11c>)
 800125c:	4a28      	ldr	r2, [pc, #160]	; (8001300 <SetSysClock+0x11c>)
 800125e:	6892      	ldr	r2, [r2, #8]
 8001260:	609a      	str	r2, [r3, #8]
      
    /* PCLK2 = HCLK / 2*/
    RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
 8001262:	4b27      	ldr	r3, [pc, #156]	; (8001300 <SetSysClock+0x11c>)
 8001264:	4a26      	ldr	r2, [pc, #152]	; (8001300 <SetSysClock+0x11c>)
 8001266:	6892      	ldr	r2, [r2, #8]
 8001268:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800126c:	609a      	str	r2, [r3, #8]
    
    /* PCLK1 = HCLK / 4*/
    RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
 800126e:	4b24      	ldr	r3, [pc, #144]	; (8001300 <SetSysClock+0x11c>)
 8001270:	4a23      	ldr	r2, [pc, #140]	; (8001300 <SetSysClock+0x11c>)
 8001272:	6892      	ldr	r2, [r2, #8]
 8001274:	f442 52a0 	orr.w	r2, r2, #5120	; 0x1400
 8001278:	609a      	str	r2, [r3, #8]

    /* Configure the main PLL */
    RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 800127a:	4b21      	ldr	r3, [pc, #132]	; (8001300 <SetSysClock+0x11c>)
 800127c:	4a22      	ldr	r2, [pc, #136]	; (8001308 <SetSysClock+0x124>)
 800127e:	605a      	str	r2, [r3, #4]
                   (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);

    /* Enable the main PLL */
    RCC->CR |= RCC_CR_PLLON;
 8001280:	4b1f      	ldr	r3, [pc, #124]	; (8001300 <SetSysClock+0x11c>)
 8001282:	4a1f      	ldr	r2, [pc, #124]	; (8001300 <SetSysClock+0x11c>)
 8001284:	6812      	ldr	r2, [r2, #0]
 8001286:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800128a:	601a      	str	r2, [r3, #0]

    /* Wait till the main PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 800128c:	bf00      	nop
 800128e:	4b1c      	ldr	r3, [pc, #112]	; (8001300 <SetSysClock+0x11c>)
 8001290:	681b      	ldr	r3, [r3, #0]
 8001292:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8001296:	2b00      	cmp	r3, #0
 8001298:	d0f9      	beq.n	800128e <SetSysClock+0xaa>
    {
    }
   
    /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
    FLASH->ACR = FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
 800129a:	4b1c      	ldr	r3, [pc, #112]	; (800130c <SetSysClock+0x128>)
 800129c:	f240 6205 	movw	r2, #1541	; 0x605
 80012a0:	601a      	str	r2, [r3, #0]

    /* Select the main PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 80012a2:	4b17      	ldr	r3, [pc, #92]	; (8001300 <SetSysClock+0x11c>)
 80012a4:	4a16      	ldr	r2, [pc, #88]	; (8001300 <SetSysClock+0x11c>)
 80012a6:	6892      	ldr	r2, [r2, #8]
 80012a8:	f022 0203 	bic.w	r2, r2, #3
 80012ac:	609a      	str	r2, [r3, #8]
    RCC->CFGR |= RCC_CFGR_SW_PLL;
 80012ae:	4b14      	ldr	r3, [pc, #80]	; (8001300 <SetSysClock+0x11c>)
 80012b0:	4a13      	ldr	r2, [pc, #76]	; (8001300 <SetSysClock+0x11c>)
 80012b2:	6892      	ldr	r2, [r2, #8]
 80012b4:	f042 0202 	orr.w	r2, r2, #2
 80012b8:	609a      	str	r2, [r3, #8]

    /* Wait till the main PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
 80012ba:	bf00      	nop
 80012bc:	4b10      	ldr	r3, [pc, #64]	; (8001300 <SetSysClock+0x11c>)
 80012be:	689b      	ldr	r3, [r3, #8]
 80012c0:	f003 030c 	and.w	r3, r3, #12
 80012c4:	2b08      	cmp	r3, #8
 80012c6:	d1f9      	bne.n	80012bc <SetSysClock+0xd8>

/******************************************************************************/
/*                        I2S clock configuration                             */
/******************************************************************************/
  /* PLLI2S clock used as I2S clock source */
  RCC->CFGR &= ~RCC_CFGR_I2SSRC;
 80012c8:	4b0d      	ldr	r3, [pc, #52]	; (8001300 <SetSysClock+0x11c>)
 80012ca:	4a0d      	ldr	r2, [pc, #52]	; (8001300 <SetSysClock+0x11c>)
 80012cc:	6892      	ldr	r2, [r2, #8]
 80012ce:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 80012d2:	609a      	str	r2, [r3, #8]

  /* Configure PLLI2S */
  RCC->PLLI2SCFGR = (PLLI2S_N << 6) | (PLLI2S_R << 28);
 80012d4:	4b0a      	ldr	r3, [pc, #40]	; (8001300 <SetSysClock+0x11c>)
 80012d6:	4a0e      	ldr	r2, [pc, #56]	; (8001310 <SetSysClock+0x12c>)
 80012d8:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  /* Enable PLLI2S */
  RCC->CR |= ((uint32_t)RCC_CR_PLLI2SON);
 80012dc:	4b08      	ldr	r3, [pc, #32]	; (8001300 <SetSysClock+0x11c>)
 80012de:	4a08      	ldr	r2, [pc, #32]	; (8001300 <SetSysClock+0x11c>)
 80012e0:	6812      	ldr	r2, [r2, #0]
 80012e2:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 80012e6:	601a      	str	r2, [r3, #0]

  /* Wait till PLLI2S is ready */
  while((RCC->CR & RCC_CR_PLLI2SRDY) == 0)
 80012e8:	bf00      	nop
 80012ea:	4b05      	ldr	r3, [pc, #20]	; (8001300 <SetSysClock+0x11c>)
 80012ec:	681b      	ldr	r3, [r3, #0]
 80012ee:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 80012f2:	2b00      	cmp	r3, #0
 80012f4:	d0f9      	beq.n	80012ea <SetSysClock+0x106>
  {
  }
}
 80012f6:	f107 070c 	add.w	r7, r7, #12
 80012fa:	46bd      	mov	sp, r7
 80012fc:	bc80      	pop	{r7}
 80012fe:	4770      	bx	lr
 8001300:	40023800 	.word	0x40023800
 8001304:	40007000 	.word	0x40007000
 8001308:	07405408 	.word	0x07405408
 800130c:	40023c00 	.word	0x40023c00
 8001310:	50003000 	.word	0x50003000

08001314 <_sbrk_r>:
    return 1;
}


void *_sbrk_r(struct _reent *r, ptrdiff_t incr)
{
 8001314:	b490      	push	{r4, r7}
 8001316:	b084      	sub	sp, #16
 8001318:	af00      	add	r7, sp, #0
 800131a:	6078      	str	r0, [r7, #4]
 800131c:	6039      	str	r1, [r7, #0]
    extern char end;   // provided by the linker script

    if (__brkval == 0)
 800131e:	4b15      	ldr	r3, [pc, #84]	; (8001374 <_sbrk_r+0x60>)
 8001320:	681b      	ldr	r3, [r3, #0]
 8001322:	2b00      	cmp	r3, #0
 8001324:	d102      	bne.n	800132c <_sbrk_r+0x18>
        __brkval = &end;
 8001326:	4b13      	ldr	r3, [pc, #76]	; (8001374 <_sbrk_r+0x60>)
 8001328:	4a13      	ldr	r2, [pc, #76]	; (8001378 <_sbrk_r+0x64>)
 800132a:	601a      	str	r2, [r3, #0]

    if (__brkval + incr > (char*)__get_MSP() - __malloc_margin) {
 800132c:	4b11      	ldr	r3, [pc, #68]	; (8001374 <_sbrk_r+0x60>)
 800132e:	681a      	ldr	r2, [r3, #0]
 8001330:	683b      	ldr	r3, [r7, #0]
 8001332:	18d2      	adds	r2, r2, r3
 */
__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_MSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
 8001334:	f3ef 8408 	mrs	r4, MSP
  return(result);
 8001338:	4623      	mov	r3, r4
 800133a:	4619      	mov	r1, r3
 800133c:	4b0f      	ldr	r3, [pc, #60]	; (800137c <_sbrk_r+0x68>)
 800133e:	681b      	ldr	r3, [r3, #0]
 8001340:	1acb      	subs	r3, r1, r3
 8001342:	429a      	cmp	r2, r3
 8001344:	d906      	bls.n	8001354 <_sbrk_r+0x40>
        r->_errno = ENOMEM;
 8001346:	687b      	ldr	r3, [r7, #4]
 8001348:	f04f 020c 	mov.w	r2, #12
 800134c:	601a      	str	r2, [r3, #0]
        return (void*)-1;
 800134e:	f04f 33ff 	mov.w	r3, #4294967295
 8001352:	e009      	b.n	8001368 <_sbrk_r+0x54>
    }

    void *ret = __brkval;
 8001354:	4b07      	ldr	r3, [pc, #28]	; (8001374 <_sbrk_r+0x60>)
 8001356:	681b      	ldr	r3, [r3, #0]
 8001358:	60fb      	str	r3, [r7, #12]
    __brkval += incr;
 800135a:	4b06      	ldr	r3, [pc, #24]	; (8001374 <_sbrk_r+0x60>)
 800135c:	681a      	ldr	r2, [r3, #0]
 800135e:	683b      	ldr	r3, [r7, #0]
 8001360:	18d2      	adds	r2, r2, r3
 8001362:	4b04      	ldr	r3, [pc, #16]	; (8001374 <_sbrk_r+0x60>)
 8001364:	601a      	str	r2, [r3, #0]

    return ret;
 8001366:	68fb      	ldr	r3, [r7, #12]
}
 8001368:	4618      	mov	r0, r3
 800136a:	f107 0710 	add.w	r7, r7, #16
 800136e:	46bd      	mov	sp, r7
 8001370:	bc90      	pop	{r4, r7}
 8001372:	4770      	bx	lr
 8001374:	200007a0 	.word	0x200007a0
 8001378:	200007a4 	.word	0x200007a4
 800137c:	20000528 	.word	0x20000528

08001380 <__malloc_lock>:
    return -1;
}


void __malloc_lock(struct _reent *r)
{
 8001380:	b580      	push	{r7, lr}
 8001382:	b082      	sub	sp, #8
 8001384:	af00      	add	r7, sp, #0
 8001386:	6078      	str	r0, [r7, #4]
    vPortEnterCritical();
 8001388:	f000 fcc6 	bl	8001d18 <vPortEnterCritical>
}
 800138c:	f107 0708 	add.w	r7, r7, #8
 8001390:	46bd      	mov	sp, r7
 8001392:	bd80      	pop	{r7, pc}

08001394 <__malloc_unlock>:


void __malloc_unlock(struct _reent *r)
{
 8001394:	b580      	push	{r7, lr}
 8001396:	b082      	sub	sp, #8
 8001398:	af00      	add	r7, sp, #0
 800139a:	6078      	str	r0, [r7, #4]
    vPortExitCritical();
 800139c:	f000 fcce 	bl	8001d3c <vPortExitCritical>
}
 80013a0:	f107 0708 	add.w	r7, r7, #8
 80013a4:	46bd      	mov	sp, r7
 80013a6:	bd80      	pop	{r7, pc}

080013a8 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
 80013a8:	b580      	push	{r7, lr}
 80013aa:	b08a      	sub	sp, #40	; 0x28
 80013ac:	af02      	add	r7, sp, #8
 80013ae:	60f8      	str	r0, [r7, #12]
 80013b0:	60b9      	str	r1, [r7, #8]
 80013b2:	603b      	str	r3, [r7, #0]
 80013b4:	4613      	mov	r3, r2
 80013b6:	80fb      	strh	r3, [r7, #6]
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 80013b8:	88fb      	ldrh	r3, [r7, #6]
 80013ba:	4618      	mov	r0, r3
 80013bc:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80013be:	f000 fb59 	bl	8001a74 <prvAllocateTCBAndStack>
 80013c2:	61b8      	str	r0, [r7, #24]

	if( pxNewTCB != NULL )
 80013c4:	69bb      	ldr	r3, [r7, #24]
 80013c6:	2b00      	cmp	r3, #0
 80013c8:	d078      	beq.n	80014bc <xTaskGenericCreate+0x114>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 80013ca:	69bb      	ldr	r3, [r7, #24]
 80013cc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80013ce:	88fb      	ldrh	r3, [r7, #6]
 80013d0:	f103 33ff 	add.w	r3, r3, #4294967295
 80013d4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80013d8:	18d3      	adds	r3, r2, r3
 80013da:	617b      	str	r3, [r7, #20]
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) );
 80013dc:	697b      	ldr	r3, [r7, #20]
 80013de:	f023 0307 	bic.w	r3, r3, #7
 80013e2:	617b      	str	r3, [r7, #20]
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 80013e4:	88fb      	ldrh	r3, [r7, #6]
 80013e6:	9300      	str	r3, [sp, #0]
 80013e8:	69b8      	ldr	r0, [r7, #24]
 80013ea:	68b9      	ldr	r1, [r7, #8]
 80013ec:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80013ee:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80013f0:	f000 fa7a 	bl	80018e8 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 80013f4:	6978      	ldr	r0, [r7, #20]
 80013f6:	68f9      	ldr	r1, [r7, #12]
 80013f8:	683a      	ldr	r2, [r7, #0]
 80013fa:	f000 fc09 	bl	8001c10 <pxPortInitialiseStack>
 80013fe:	4603      	mov	r3, r0
 8001400:	461a      	mov	r2, r3
 8001402:	69bb      	ldr	r3, [r7, #24]
 8001404:	601a      	str	r2, [r3, #0]
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
 8001406:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001408:	2b00      	cmp	r3, #0
 800140a:	d002      	beq.n	8001412 <xTaskGenericCreate+0x6a>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 800140c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800140e:	69ba      	ldr	r2, [r7, #24]
 8001410:	601a      	str	r2, [r3, #0]
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
 8001412:	f000 fc81 	bl	8001d18 <vPortEnterCritical>
		{
			uxCurrentNumberOfTasks++;
 8001416:	4b35      	ldr	r3, [pc, #212]	; (80014ec <xTaskGenericCreate+0x144>)
 8001418:	681b      	ldr	r3, [r3, #0]
 800141a:	f103 0201 	add.w	r2, r3, #1
 800141e:	4b33      	ldr	r3, [pc, #204]	; (80014ec <xTaskGenericCreate+0x144>)
 8001420:	601a      	str	r2, [r3, #0]
			if( pxCurrentTCB == NULL )
 8001422:	4b33      	ldr	r3, [pc, #204]	; (80014f0 <xTaskGenericCreate+0x148>)
 8001424:	681b      	ldr	r3, [r3, #0]
 8001426:	2b00      	cmp	r3, #0
 8001428:	d109      	bne.n	800143e <xTaskGenericCreate+0x96>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 800142a:	4b31      	ldr	r3, [pc, #196]	; (80014f0 <xTaskGenericCreate+0x148>)
 800142c:	69ba      	ldr	r2, [r7, #24]
 800142e:	601a      	str	r2, [r3, #0]

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 8001430:	4b2e      	ldr	r3, [pc, #184]	; (80014ec <xTaskGenericCreate+0x144>)
 8001432:	681b      	ldr	r3, [r3, #0]
 8001434:	2b01      	cmp	r3, #1
 8001436:	d10f      	bne.n	8001458 <xTaskGenericCreate+0xb0>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
 8001438:	f000 fa9c 	bl	8001974 <prvInitialiseTaskLists>
 800143c:	e00c      	b.n	8001458 <xTaskGenericCreate+0xb0>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 800143e:	4b2d      	ldr	r3, [pc, #180]	; (80014f4 <xTaskGenericCreate+0x14c>)
 8001440:	681b      	ldr	r3, [r3, #0]
 8001442:	2b00      	cmp	r3, #0
 8001444:	d108      	bne.n	8001458 <xTaskGenericCreate+0xb0>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 8001446:	4b2a      	ldr	r3, [pc, #168]	; (80014f0 <xTaskGenericCreate+0x148>)
 8001448:	681b      	ldr	r3, [r3, #0]
 800144a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800144c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800144e:	429a      	cmp	r2, r3
 8001450:	d802      	bhi.n	8001458 <xTaskGenericCreate+0xb0>
					{
						pxCurrentTCB = pxNewTCB;
 8001452:	4b27      	ldr	r3, [pc, #156]	; (80014f0 <xTaskGenericCreate+0x148>)
 8001454:	69ba      	ldr	r2, [r7, #24]
 8001456:	601a      	str	r2, [r3, #0]
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 8001458:	69bb      	ldr	r3, [r7, #24]
 800145a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800145c:	4b26      	ldr	r3, [pc, #152]	; (80014f8 <xTaskGenericCreate+0x150>)
 800145e:	681b      	ldr	r3, [r3, #0]
 8001460:	429a      	cmp	r2, r3
 8001462:	d903      	bls.n	800146c <xTaskGenericCreate+0xc4>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
 8001464:	69bb      	ldr	r3, [r7, #24]
 8001466:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001468:	4b23      	ldr	r3, [pc, #140]	; (80014f8 <xTaskGenericCreate+0x150>)
 800146a:	601a      	str	r2, [r3, #0]
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
 800146c:	4b23      	ldr	r3, [pc, #140]	; (80014fc <xTaskGenericCreate+0x154>)
 800146e:	681b      	ldr	r3, [r3, #0]
 8001470:	f103 0201 	add.w	r2, r3, #1
 8001474:	4b21      	ldr	r3, [pc, #132]	; (80014fc <xTaskGenericCreate+0x154>)
 8001476:	601a      	str	r2, [r3, #0]

			prvAddTaskToReadyQueue( pxNewTCB );
 8001478:	69bb      	ldr	r3, [r7, #24]
 800147a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800147c:	4b20      	ldr	r3, [pc, #128]	; (8001500 <xTaskGenericCreate+0x158>)
 800147e:	681b      	ldr	r3, [r3, #0]
 8001480:	429a      	cmp	r2, r3
 8001482:	d903      	bls.n	800148c <xTaskGenericCreate+0xe4>
 8001484:	69bb      	ldr	r3, [r7, #24]
 8001486:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001488:	4b1d      	ldr	r3, [pc, #116]	; (8001500 <xTaskGenericCreate+0x158>)
 800148a:	601a      	str	r2, [r3, #0]
 800148c:	69bb      	ldr	r3, [r7, #24]
 800148e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001490:	4613      	mov	r3, r2
 8001492:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001496:	189b      	adds	r3, r3, r2
 8001498:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800149c:	461a      	mov	r2, r3
 800149e:	4b19      	ldr	r3, [pc, #100]	; (8001504 <xTaskGenericCreate+0x15c>)
 80014a0:	18d2      	adds	r2, r2, r3
 80014a2:	69bb      	ldr	r3, [r7, #24]
 80014a4:	f103 0304 	add.w	r3, r3, #4
 80014a8:	4610      	mov	r0, r2
 80014aa:	4619      	mov	r1, r3
 80014ac:	f000 fb5e 	bl	8001b6c <vListInsertEnd>

			xReturn = pdPASS;
 80014b0:	f04f 0301 	mov.w	r3, #1
 80014b4:	61fb      	str	r3, [r7, #28]
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 80014b6:	f000 fc41 	bl	8001d3c <vPortExitCritical>
 80014ba:	e002      	b.n	80014c2 <xTaskGenericCreate+0x11a>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 80014bc:	f04f 33ff 	mov.w	r3, #4294967295
 80014c0:	61fb      	str	r3, [r7, #28]
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
 80014c2:	69fb      	ldr	r3, [r7, #28]
 80014c4:	2b01      	cmp	r3, #1
 80014c6:	d10b      	bne.n	80014e0 <xTaskGenericCreate+0x138>
	{
		if( xSchedulerRunning != pdFALSE )
 80014c8:	4b0a      	ldr	r3, [pc, #40]	; (80014f4 <xTaskGenericCreate+0x14c>)
 80014ca:	681b      	ldr	r3, [r3, #0]
 80014cc:	2b00      	cmp	r3, #0
 80014ce:	d007      	beq.n	80014e0 <xTaskGenericCreate+0x138>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 80014d0:	4b07      	ldr	r3, [pc, #28]	; (80014f0 <xTaskGenericCreate+0x148>)
 80014d2:	681b      	ldr	r3, [r3, #0]
 80014d4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80014d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80014d8:	429a      	cmp	r2, r3
 80014da:	d201      	bcs.n	80014e0 <xTaskGenericCreate+0x138>
			{
				portYIELD_WITHIN_API();
 80014dc:	f000 fc10 	bl	8001d00 <vPortYieldFromISR>
			}
		}
	}

	return xReturn;
 80014e0:	69fb      	ldr	r3, [r7, #28]
}
 80014e2:	4618      	mov	r0, r3
 80014e4:	f107 0720 	add.w	r7, r7, #32
 80014e8:	46bd      	mov	sp, r7
 80014ea:	bd80      	pop	{r7, pc}
 80014ec:	20000774 	.word	0x20000774
 80014f0:	20000698 	.word	0x20000698
 80014f4:	20000784 	.word	0x20000784
 80014f8:	2000077c 	.word	0x2000077c
 80014fc:	20000798 	.word	0x20000798
 8001500:	20000780 	.word	0x20000780
 8001504:	2000069c 	.word	0x2000069c

08001508 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
 8001508:	b580      	push	{r7, lr}
 800150a:	b086      	sub	sp, #24
 800150c:	af04      	add	r7, sp, #16
	/* Add the idle task at the lowest priority. */
	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
	{
		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
		be returned by the xTaskGetIdleTaskHandle() function. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
 800150e:	4b16      	ldr	r3, [pc, #88]	; (8001568 <vTaskStartScheduler+0x60>)
 8001510:	f04f 0200 	mov.w	r2, #0
 8001514:	9200      	str	r2, [sp, #0]
 8001516:	4a15      	ldr	r2, [pc, #84]	; (800156c <vTaskStartScheduler+0x64>)
 8001518:	9201      	str	r2, [sp, #4]
 800151a:	f04f 0200 	mov.w	r2, #0
 800151e:	9202      	str	r2, [sp, #8]
 8001520:	f04f 0200 	mov.w	r2, #0
 8001524:	9203      	str	r2, [sp, #12]
 8001526:	4812      	ldr	r0, [pc, #72]	; (8001570 <vTaskStartScheduler+0x68>)
 8001528:	4619      	mov	r1, r3
 800152a:	f44f 7280 	mov.w	r2, #256	; 0x100
 800152e:	f04f 0300 	mov.w	r3, #0
 8001532:	f7ff ff39 	bl	80013a8 <xTaskGenericCreate>
 8001536:	6078      	str	r0, [r7, #4]
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
 8001538:	687b      	ldr	r3, [r7, #4]
 800153a:	2b01      	cmp	r3, #1
 800153c:	d10f      	bne.n	800155e <vTaskStartScheduler+0x56>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
 800153e:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8001542:	f380 8811 	msr	BASEPRI, r0

		xSchedulerRunning = pdTRUE;
 8001546:	4b0b      	ldr	r3, [pc, #44]	; (8001574 <vTaskStartScheduler+0x6c>)
 8001548:	f04f 0201 	mov.w	r2, #1
 800154c:	601a      	str	r2, [r3, #0]
		xTickCount = ( portTickType ) 0U;
 800154e:	4b0a      	ldr	r3, [pc, #40]	; (8001578 <vTaskStartScheduler+0x70>)
 8001550:	f04f 0200 	mov.w	r2, #0
 8001554:	601a      	str	r2, [r3, #0]

		/* If configGENERATE_RUN_TIME_STATS is defined then the following
		macro must be defined to configure the timer/counter used to generate
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
 8001556:	f7ff fcf3 	bl	8000f40 <init_us_timer>
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 800155a:	f000 fba9 	bl	8001cb0 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
 800155e:	f107 0708 	add.w	r7, r7, #8
 8001562:	46bd      	mov	sp, r7
 8001564:	bd80      	pop	{r7, pc}
 8001566:	bf00      	nop
 8001568:	080024b0 	.word	0x080024b0
 800156c:	20000770 	.word	0x20000770
 8001570:	080018c5 	.word	0x080018c5
 8001574:	20000784 	.word	0x20000784
 8001578:	20000778 	.word	0x20000778

0800157c <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 800157c:	b480      	push	{r7}
 800157e:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
 8001580:	4b04      	ldr	r3, [pc, #16]	; (8001594 <vTaskSuspendAll+0x18>)
 8001582:	681b      	ldr	r3, [r3, #0]
 8001584:	f103 0201 	add.w	r2, r3, #1
 8001588:	4b02      	ldr	r3, [pc, #8]	; (8001594 <vTaskSuspendAll+0x18>)
 800158a:	601a      	str	r2, [r3, #0]
}
 800158c:	46bd      	mov	sp, r7
 800158e:	bc80      	pop	{r7}
 8001590:	4770      	bx	lr
 8001592:	bf00      	nop
 8001594:	20000788 	.word	0x20000788

08001598 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
 8001598:	b590      	push	{r4, r7, lr}
 800159a:	b083      	sub	sp, #12
 800159c:	af00      	add	r7, sp, #0
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 800159e:	f04f 0300 	mov.w	r3, #0
 80015a2:	607b      	str	r3, [r7, #4]
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 80015a4:	f000 fbb8 	bl	8001d18 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 80015a8:	4b38      	ldr	r3, [pc, #224]	; (800168c <xTaskResumeAll+0xf4>)
 80015aa:	681b      	ldr	r3, [r3, #0]
 80015ac:	f103 32ff 	add.w	r2, r3, #4294967295
 80015b0:	4b36      	ldr	r3, [pc, #216]	; (800168c <xTaskResumeAll+0xf4>)
 80015b2:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 80015b4:	4b35      	ldr	r3, [pc, #212]	; (800168c <xTaskResumeAll+0xf4>)
 80015b6:	681b      	ldr	r3, [r3, #0]
 80015b8:	2b00      	cmp	r3, #0
 80015ba:	d15e      	bne.n	800167a <xTaskResumeAll+0xe2>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 80015bc:	4b34      	ldr	r3, [pc, #208]	; (8001690 <xTaskResumeAll+0xf8>)
 80015be:	681b      	ldr	r3, [r3, #0]
 80015c0:	2b00      	cmp	r3, #0
 80015c2:	d05a      	beq.n	800167a <xTaskResumeAll+0xe2>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
 80015c4:	f04f 0300 	mov.w	r3, #0
 80015c8:	603b      	str	r3, [r7, #0]

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 80015ca:	e02e      	b.n	800162a <xTaskResumeAll+0x92>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 80015cc:	4b31      	ldr	r3, [pc, #196]	; (8001694 <xTaskResumeAll+0xfc>)
 80015ce:	68db      	ldr	r3, [r3, #12]
 80015d0:	68db      	ldr	r3, [r3, #12]
 80015d2:	461c      	mov	r4, r3
					vListRemove( &( pxTCB->xEventListItem ) );
 80015d4:	f104 0318 	add.w	r3, r4, #24
 80015d8:	4618      	mov	r0, r3
 80015da:	f000 faef 	bl	8001bbc <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
 80015de:	f104 0304 	add.w	r3, r4, #4
 80015e2:	4618      	mov	r0, r3
 80015e4:	f000 faea 	bl	8001bbc <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
 80015e8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80015ea:	4b2b      	ldr	r3, [pc, #172]	; (8001698 <xTaskResumeAll+0x100>)
 80015ec:	681b      	ldr	r3, [r3, #0]
 80015ee:	429a      	cmp	r2, r3
 80015f0:	d902      	bls.n	80015f8 <xTaskResumeAll+0x60>
 80015f2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80015f4:	4b28      	ldr	r3, [pc, #160]	; (8001698 <xTaskResumeAll+0x100>)
 80015f6:	601a      	str	r2, [r3, #0]
 80015f8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80015fa:	4613      	mov	r3, r2
 80015fc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001600:	189b      	adds	r3, r3, r2
 8001602:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001606:	461a      	mov	r2, r3
 8001608:	4b24      	ldr	r3, [pc, #144]	; (800169c <xTaskResumeAll+0x104>)
 800160a:	18d2      	adds	r2, r2, r3
 800160c:	f104 0304 	add.w	r3, r4, #4
 8001610:	4610      	mov	r0, r2
 8001612:	4619      	mov	r1, r3
 8001614:	f000 faaa 	bl	8001b6c <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8001618:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800161a:	4b21      	ldr	r3, [pc, #132]	; (80016a0 <xTaskResumeAll+0x108>)
 800161c:	681b      	ldr	r3, [r3, #0]
 800161e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001620:	429a      	cmp	r2, r3
 8001622:	d302      	bcc.n	800162a <xTaskResumeAll+0x92>
					{
						xYieldRequired = pdTRUE;
 8001624:	f04f 0301 	mov.w	r3, #1
 8001628:	603b      	str	r3, [r7, #0]
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 800162a:	4b1a      	ldr	r3, [pc, #104]	; (8001694 <xTaskResumeAll+0xfc>)
 800162c:	681b      	ldr	r3, [r3, #0]
 800162e:	2b00      	cmp	r3, #0
 8001630:	d1cc      	bne.n	80015cc <xTaskResumeAll+0x34>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 8001632:	4b1c      	ldr	r3, [pc, #112]	; (80016a4 <xTaskResumeAll+0x10c>)
 8001634:	681b      	ldr	r3, [r3, #0]
 8001636:	2b00      	cmp	r3, #0
 8001638:	d00f      	beq.n	800165a <xTaskResumeAll+0xc2>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 800163a:	e007      	b.n	800164c <xTaskResumeAll+0xb4>
					{
						vTaskIncrementTick();
 800163c:	f000 f836 	bl	80016ac <vTaskIncrementTick>
						--uxMissedTicks;
 8001640:	4b18      	ldr	r3, [pc, #96]	; (80016a4 <xTaskResumeAll+0x10c>)
 8001642:	681b      	ldr	r3, [r3, #0]
 8001644:	f103 32ff 	add.w	r2, r3, #4294967295
 8001648:	4b16      	ldr	r3, [pc, #88]	; (80016a4 <xTaskResumeAll+0x10c>)
 800164a:	601a      	str	r2, [r3, #0]
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 800164c:	4b15      	ldr	r3, [pc, #84]	; (80016a4 <xTaskResumeAll+0x10c>)
 800164e:	681b      	ldr	r3, [r3, #0]
 8001650:	2b00      	cmp	r3, #0
 8001652:	d1f3      	bne.n	800163c <xTaskResumeAll+0xa4>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
 8001654:	f04f 0301 	mov.w	r3, #1
 8001658:	603b      	str	r3, [r7, #0]
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 800165a:	683b      	ldr	r3, [r7, #0]
 800165c:	2b01      	cmp	r3, #1
 800165e:	d003      	beq.n	8001668 <xTaskResumeAll+0xd0>
 8001660:	4b11      	ldr	r3, [pc, #68]	; (80016a8 <xTaskResumeAll+0x110>)
 8001662:	681b      	ldr	r3, [r3, #0]
 8001664:	2b01      	cmp	r3, #1
 8001666:	d108      	bne.n	800167a <xTaskResumeAll+0xe2>
				{
					xAlreadyYielded = pdTRUE;
 8001668:	f04f 0301 	mov.w	r3, #1
 800166c:	607b      	str	r3, [r7, #4]
					xMissedYield = pdFALSE;
 800166e:	4b0e      	ldr	r3, [pc, #56]	; (80016a8 <xTaskResumeAll+0x110>)
 8001670:	f04f 0200 	mov.w	r2, #0
 8001674:	601a      	str	r2, [r3, #0]
					portYIELD_WITHIN_API();
 8001676:	f000 fb43 	bl	8001d00 <vPortYieldFromISR>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
 800167a:	f000 fb5f 	bl	8001d3c <vPortExitCritical>

	return xAlreadyYielded;
 800167e:	687b      	ldr	r3, [r7, #4]
}
 8001680:	4618      	mov	r0, r3
 8001682:	f107 070c 	add.w	r7, r7, #12
 8001686:	46bd      	mov	sp, r7
 8001688:	bd90      	pop	{r4, r7, pc}
 800168a:	bf00      	nop
 800168c:	20000788 	.word	0x20000788
 8001690:	20000774 	.word	0x20000774
 8001694:	20000730 	.word	0x20000730
 8001698:	20000780 	.word	0x20000780
 800169c:	2000069c 	.word	0x2000069c
 80016a0:	20000698 	.word	0x20000698
 80016a4:	2000078c 	.word	0x2000078c
 80016a8:	20000790 	.word	0x20000790

080016ac <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
 80016ac:	b580      	push	{r7, lr}
 80016ae:	b084      	sub	sp, #16
 80016b0:	af00      	add	r7, sp, #0
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 80016b2:	4b44      	ldr	r3, [pc, #272]	; (80017c4 <vTaskIncrementTick+0x118>)
 80016b4:	681b      	ldr	r3, [r3, #0]
 80016b6:	2b00      	cmp	r3, #0
 80016b8:	d17a      	bne.n	80017b0 <vTaskIncrementTick+0x104>
	{
		++xTickCount;
 80016ba:	4b43      	ldr	r3, [pc, #268]	; (80017c8 <vTaskIncrementTick+0x11c>)
 80016bc:	681b      	ldr	r3, [r3, #0]
 80016be:	f103 0201 	add.w	r2, r3, #1
 80016c2:	4b41      	ldr	r3, [pc, #260]	; (80017c8 <vTaskIncrementTick+0x11c>)
 80016c4:	601a      	str	r2, [r3, #0]
		if( xTickCount == ( portTickType ) 0U )
 80016c6:	4b40      	ldr	r3, [pc, #256]	; (80017c8 <vTaskIncrementTick+0x11c>)
 80016c8:	681b      	ldr	r3, [r3, #0]
 80016ca:	2b00      	cmp	r3, #0
 80016cc:	d122      	bne.n	8001714 <vTaskIncrementTick+0x68>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
 80016ce:	4b3f      	ldr	r3, [pc, #252]	; (80017cc <vTaskIncrementTick+0x120>)
 80016d0:	681b      	ldr	r3, [r3, #0]
 80016d2:	60fb      	str	r3, [r7, #12]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
 80016d4:	4b3e      	ldr	r3, [pc, #248]	; (80017d0 <vTaskIncrementTick+0x124>)
 80016d6:	681a      	ldr	r2, [r3, #0]
 80016d8:	4b3c      	ldr	r3, [pc, #240]	; (80017cc <vTaskIncrementTick+0x120>)
 80016da:	601a      	str	r2, [r3, #0]
			pxOverflowDelayedTaskList = pxTemp;
 80016dc:	4b3c      	ldr	r3, [pc, #240]	; (80017d0 <vTaskIncrementTick+0x124>)
 80016de:	68fa      	ldr	r2, [r7, #12]
 80016e0:	601a      	str	r2, [r3, #0]
			xNumOfOverflows++;
 80016e2:	4b3c      	ldr	r3, [pc, #240]	; (80017d4 <vTaskIncrementTick+0x128>)
 80016e4:	681b      	ldr	r3, [r3, #0]
 80016e6:	f103 0201 	add.w	r2, r3, #1
 80016ea:	4b3a      	ldr	r3, [pc, #232]	; (80017d4 <vTaskIncrementTick+0x128>)
 80016ec:	601a      	str	r2, [r3, #0]
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80016ee:	4b37      	ldr	r3, [pc, #220]	; (80017cc <vTaskIncrementTick+0x120>)
 80016f0:	681b      	ldr	r3, [r3, #0]
 80016f2:	681b      	ldr	r3, [r3, #0]
 80016f4:	2b00      	cmp	r3, #0
 80016f6:	d104      	bne.n	8001702 <vTaskIncrementTick+0x56>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
 80016f8:	4b37      	ldr	r3, [pc, #220]	; (80017d8 <vTaskIncrementTick+0x12c>)
 80016fa:	f04f 32ff 	mov.w	r2, #4294967295
 80016fe:	601a      	str	r2, [r3, #0]
 8001700:	e008      	b.n	8001714 <vTaskIncrementTick+0x68>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8001702:	4b32      	ldr	r3, [pc, #200]	; (80017cc <vTaskIncrementTick+0x120>)
 8001704:	681b      	ldr	r3, [r3, #0]
 8001706:	68db      	ldr	r3, [r3, #12]
 8001708:	68db      	ldr	r3, [r3, #12]
 800170a:	60bb      	str	r3, [r7, #8]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 800170c:	68bb      	ldr	r3, [r7, #8]
 800170e:	685a      	ldr	r2, [r3, #4]
 8001710:	4b31      	ldr	r3, [pc, #196]	; (80017d8 <vTaskIncrementTick+0x12c>)
 8001712:	601a      	str	r2, [r3, #0]
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
 8001714:	4b2c      	ldr	r3, [pc, #176]	; (80017c8 <vTaskIncrementTick+0x11c>)
 8001716:	681a      	ldr	r2, [r3, #0]
 8001718:	4b2f      	ldr	r3, [pc, #188]	; (80017d8 <vTaskIncrementTick+0x12c>)
 800171a:	681b      	ldr	r3, [r3, #0]
 800171c:	429a      	cmp	r2, r3
 800171e:	d34d      	bcc.n	80017bc <vTaskIncrementTick+0x110>
 8001720:	4b2a      	ldr	r3, [pc, #168]	; (80017cc <vTaskIncrementTick+0x120>)
 8001722:	681b      	ldr	r3, [r3, #0]
 8001724:	681b      	ldr	r3, [r3, #0]
 8001726:	2b00      	cmp	r3, #0
 8001728:	d104      	bne.n	8001734 <vTaskIncrementTick+0x88>
 800172a:	4b2b      	ldr	r3, [pc, #172]	; (80017d8 <vTaskIncrementTick+0x12c>)
 800172c:	f04f 32ff 	mov.w	r2, #4294967295
 8001730:	601a      	str	r2, [r3, #0]
 8001732:	e043      	b.n	80017bc <vTaskIncrementTick+0x110>
 8001734:	4b25      	ldr	r3, [pc, #148]	; (80017cc <vTaskIncrementTick+0x120>)
 8001736:	681b      	ldr	r3, [r3, #0]
 8001738:	68db      	ldr	r3, [r3, #12]
 800173a:	68db      	ldr	r3, [r3, #12]
 800173c:	60bb      	str	r3, [r7, #8]
 800173e:	68bb      	ldr	r3, [r7, #8]
 8001740:	685b      	ldr	r3, [r3, #4]
 8001742:	607b      	str	r3, [r7, #4]
 8001744:	4b20      	ldr	r3, [pc, #128]	; (80017c8 <vTaskIncrementTick+0x11c>)
 8001746:	681a      	ldr	r2, [r3, #0]
 8001748:	687b      	ldr	r3, [r7, #4]
 800174a:	429a      	cmp	r2, r3
 800174c:	d203      	bcs.n	8001756 <vTaskIncrementTick+0xaa>
 800174e:	4b22      	ldr	r3, [pc, #136]	; (80017d8 <vTaskIncrementTick+0x12c>)
 8001750:	687a      	ldr	r2, [r7, #4]
 8001752:	601a      	str	r2, [r3, #0]
 8001754:	e032      	b.n	80017bc <vTaskIncrementTick+0x110>
 8001756:	68bb      	ldr	r3, [r7, #8]
 8001758:	f103 0304 	add.w	r3, r3, #4
 800175c:	4618      	mov	r0, r3
 800175e:	f000 fa2d 	bl	8001bbc <vListRemove>
 8001762:	68bb      	ldr	r3, [r7, #8]
 8001764:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001766:	2b00      	cmp	r3, #0
 8001768:	d005      	beq.n	8001776 <vTaskIncrementTick+0xca>
 800176a:	68bb      	ldr	r3, [r7, #8]
 800176c:	f103 0318 	add.w	r3, r3, #24
 8001770:	4618      	mov	r0, r3
 8001772:	f000 fa23 	bl	8001bbc <vListRemove>
 8001776:	68bb      	ldr	r3, [r7, #8]
 8001778:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800177a:	4b18      	ldr	r3, [pc, #96]	; (80017dc <vTaskIncrementTick+0x130>)
 800177c:	681b      	ldr	r3, [r3, #0]
 800177e:	429a      	cmp	r2, r3
 8001780:	d903      	bls.n	800178a <vTaskIncrementTick+0xde>
 8001782:	68bb      	ldr	r3, [r7, #8]
 8001784:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001786:	4b15      	ldr	r3, [pc, #84]	; (80017dc <vTaskIncrementTick+0x130>)
 8001788:	601a      	str	r2, [r3, #0]
 800178a:	68bb      	ldr	r3, [r7, #8]
 800178c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800178e:	4613      	mov	r3, r2
 8001790:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001794:	189b      	adds	r3, r3, r2
 8001796:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800179a:	461a      	mov	r2, r3
 800179c:	4b10      	ldr	r3, [pc, #64]	; (80017e0 <vTaskIncrementTick+0x134>)
 800179e:	18d2      	adds	r2, r2, r3
 80017a0:	68bb      	ldr	r3, [r7, #8]
 80017a2:	f103 0304 	add.w	r3, r3, #4
 80017a6:	4610      	mov	r0, r2
 80017a8:	4619      	mov	r1, r3
 80017aa:	f000 f9df 	bl	8001b6c <vListInsertEnd>
 80017ae:	e7b7      	b.n	8001720 <vTaskIncrementTick+0x74>
	}
	else
	{
		++uxMissedTicks;
 80017b0:	4b0c      	ldr	r3, [pc, #48]	; (80017e4 <vTaskIncrementTick+0x138>)
 80017b2:	681b      	ldr	r3, [r3, #0]
 80017b4:	f103 0201 	add.w	r2, r3, #1
 80017b8:	4b0a      	ldr	r3, [pc, #40]	; (80017e4 <vTaskIncrementTick+0x138>)
 80017ba:	601a      	str	r2, [r3, #0]
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
 80017bc:	f107 0710 	add.w	r7, r7, #16
 80017c0:	46bd      	mov	sp, r7
 80017c2:	bd80      	pop	{r7, pc}
 80017c4:	20000788 	.word	0x20000788
 80017c8:	20000778 	.word	0x20000778
 80017cc:	20000728 	.word	0x20000728
 80017d0:	2000072c 	.word	0x2000072c
 80017d4:	20000794 	.word	0x20000794
 80017d8:	2000052c 	.word	0x2000052c
 80017dc:	20000780 	.word	0x20000780
 80017e0:	2000069c 	.word	0x2000069c
 80017e4:	2000078c 	.word	0x2000078c

080017e8 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 80017e8:	b580      	push	{r7, lr}
 80017ea:	b082      	sub	sp, #8
 80017ec:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 80017ee:	4b2e      	ldr	r3, [pc, #184]	; (80018a8 <vTaskSwitchContext+0xc0>)
 80017f0:	681b      	ldr	r3, [r3, #0]
 80017f2:	2b00      	cmp	r3, #0
 80017f4:	d004      	beq.n	8001800 <vTaskSwitchContext+0x18>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 80017f6:	4b2d      	ldr	r3, [pc, #180]	; (80018ac <vTaskSwitchContext+0xc4>)
 80017f8:	f04f 0201 	mov.w	r2, #1
 80017fc:	601a      	str	r2, [r3, #0]
 80017fe:	e04e      	b.n	800189e <vTaskSwitchContext+0xb6>
			unsigned long ulTempCounter;
			
				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
				#else
					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
 8001800:	f7ff fb66 	bl	8000ed0 <get_us_time>
 8001804:	4602      	mov	r2, r0
 8001806:	460b      	mov	r3, r1
 8001808:	4613      	mov	r3, r2
 800180a:	607b      	str	r3, [r7, #4]
				/* Add the amount of time the task has been running to the accumulated
				time so far.  The time the task started running was stored in
				ulTaskSwitchedInTime.  Note that there is no overflow protection here
				so count values are only valid until the timer overflows.  Generally
				this will be about 1 hour assuming a 1uS timer increment. */
				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
 800180c:	4b28      	ldr	r3, [pc, #160]	; (80018b0 <vTaskSwitchContext+0xc8>)
 800180e:	681b      	ldr	r3, [r3, #0]
 8001810:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 8001812:	4a28      	ldr	r2, [pc, #160]	; (80018b4 <vTaskSwitchContext+0xcc>)
 8001814:	6812      	ldr	r2, [r2, #0]
 8001816:	6878      	ldr	r0, [r7, #4]
 8001818:	1a82      	subs	r2, r0, r2
 800181a:	188a      	adds	r2, r1, r2
 800181c:	64da      	str	r2, [r3, #76]	; 0x4c
				ulTaskSwitchedInTime = ulTempCounter;
 800181e:	4b25      	ldr	r3, [pc, #148]	; (80018b4 <vTaskSwitchContext+0xcc>)
 8001820:	687a      	ldr	r2, [r7, #4]
 8001822:	601a      	str	r2, [r3, #0]
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 8001824:	e005      	b.n	8001832 <vTaskSwitchContext+0x4a>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
 8001826:	4b24      	ldr	r3, [pc, #144]	; (80018b8 <vTaskSwitchContext+0xd0>)
 8001828:	681b      	ldr	r3, [r3, #0]
 800182a:	f103 32ff 	add.w	r2, r3, #4294967295
 800182e:	4b22      	ldr	r3, [pc, #136]	; (80018b8 <vTaskSwitchContext+0xd0>)
 8001830:	601a      	str	r2, [r3, #0]
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 8001832:	4b21      	ldr	r3, [pc, #132]	; (80018b8 <vTaskSwitchContext+0xd0>)
 8001834:	681a      	ldr	r2, [r3, #0]
 8001836:	4613      	mov	r3, r2
 8001838:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800183c:	189b      	adds	r3, r3, r2
 800183e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001842:	461a      	mov	r2, r3
 8001844:	4b1d      	ldr	r3, [pc, #116]	; (80018bc <vTaskSwitchContext+0xd4>)
 8001846:	18d3      	adds	r3, r2, r3
 8001848:	681b      	ldr	r3, [r3, #0]
 800184a:	2b00      	cmp	r3, #0
 800184c:	d0eb      	beq.n	8001826 <vTaskSwitchContext+0x3e>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 800184e:	4b1a      	ldr	r3, [pc, #104]	; (80018b8 <vTaskSwitchContext+0xd0>)
 8001850:	681a      	ldr	r2, [r3, #0]
 8001852:	4613      	mov	r3, r2
 8001854:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001858:	189b      	adds	r3, r3, r2
 800185a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800185e:	461a      	mov	r2, r3
 8001860:	4b16      	ldr	r3, [pc, #88]	; (80018bc <vTaskSwitchContext+0xd4>)
 8001862:	18d3      	adds	r3, r2, r3
 8001864:	603b      	str	r3, [r7, #0]
 8001866:	683b      	ldr	r3, [r7, #0]
 8001868:	685b      	ldr	r3, [r3, #4]
 800186a:	685a      	ldr	r2, [r3, #4]
 800186c:	683b      	ldr	r3, [r7, #0]
 800186e:	605a      	str	r2, [r3, #4]
 8001870:	683b      	ldr	r3, [r7, #0]
 8001872:	685a      	ldr	r2, [r3, #4]
 8001874:	683b      	ldr	r3, [r7, #0]
 8001876:	f103 0308 	add.w	r3, r3, #8
 800187a:	429a      	cmp	r2, r3
 800187c:	d104      	bne.n	8001888 <vTaskSwitchContext+0xa0>
 800187e:	683b      	ldr	r3, [r7, #0]
 8001880:	685b      	ldr	r3, [r3, #4]
 8001882:	685a      	ldr	r2, [r3, #4]
 8001884:	683b      	ldr	r3, [r7, #0]
 8001886:	605a      	str	r2, [r3, #4]
 8001888:	683b      	ldr	r3, [r7, #0]
 800188a:	685b      	ldr	r3, [r3, #4]
 800188c:	68db      	ldr	r3, [r3, #12]
 800188e:	461a      	mov	r2, r3
 8001890:	4b07      	ldr	r3, [pc, #28]	; (80018b0 <vTaskSwitchContext+0xc8>)
 8001892:	601a      	str	r2, [r3, #0]
	
		traceTASK_SWITCHED_IN();
 8001894:	4b0a      	ldr	r3, [pc, #40]	; (80018c0 <vTaskSwitchContext+0xd8>)
 8001896:	4a06      	ldr	r2, [pc, #24]	; (80018b0 <vTaskSwitchContext+0xc8>)
 8001898:	6812      	ldr	r2, [r2, #0]
 800189a:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800189c:	60da      	str	r2, [r3, #12]
		vWriteTraceToBuffer();
	}
}
 800189e:	f107 0708 	add.w	r7, r7, #8
 80018a2:	46bd      	mov	sp, r7
 80018a4:	bd80      	pop	{r7, pc}
 80018a6:	bf00      	nop
 80018a8:	20000788 	.word	0x20000788
 80018ac:	20000790 	.word	0x20000790
 80018b0:	20000698 	.word	0x20000698
 80018b4:	2000079c 	.word	0x2000079c
 80018b8:	20000780 	.word	0x20000780
 80018bc:	2000069c 	.word	0x2000069c
 80018c0:	40007400 	.word	0x40007400

080018c4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 80018c4:	b580      	push	{r7, lr}
 80018c6:	b082      	sub	sp, #8
 80018c8:	af00      	add	r7, sp, #0
 80018ca:	6078      	str	r0, [r7, #4]
 80018cc:	e000      	b.n	80018d0 <prvIdleTask+0xc>
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
 80018ce:	bf00      	nop
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
 80018d0:	f000 f894 	bl	80019fc <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 80018d4:	4b03      	ldr	r3, [pc, #12]	; (80018e4 <prvIdleTask+0x20>)
 80018d6:	681b      	ldr	r3, [r3, #0]
 80018d8:	2b01      	cmp	r3, #1
 80018da:	d9f8      	bls.n	80018ce <prvIdleTask+0xa>
			{
				taskYIELD();
 80018dc:	f000 fa10 	bl	8001d00 <vPortYieldFromISR>
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
 80018e0:	e7f6      	b.n	80018d0 <prvIdleTask+0xc>
 80018e2:	bf00      	nop
 80018e4:	2000069c 	.word	0x2000069c

080018e8 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
 80018e8:	b580      	push	{r7, lr}
 80018ea:	b084      	sub	sp, #16
 80018ec:	af00      	add	r7, sp, #0
 80018ee:	60f8      	str	r0, [r7, #12]
 80018f0:	60b9      	str	r1, [r7, #8]
 80018f2:	607a      	str	r2, [r7, #4]
 80018f4:	603b      	str	r3, [r7, #0]
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
 80018f6:	68fb      	ldr	r3, [r7, #12]
 80018f8:	f103 0334 	add.w	r3, r3, #52	; 0x34
 80018fc:	461a      	mov	r2, r3
 80018fe:	68bb      	ldr	r3, [r7, #8]
 8001900:	4610      	mov	r0, r2
 8001902:	4619      	mov	r1, r3
 8001904:	f04f 0210 	mov.w	r2, #16
 8001908:	f7fe ffa6 	bl	8000858 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
 800190c:	68fb      	ldr	r3, [r7, #12]
 800190e:	f04f 0200 	mov.w	r2, #0
 8001912:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
 8001916:	687b      	ldr	r3, [r7, #4]
 8001918:	2b04      	cmp	r3, #4
 800191a:	d902      	bls.n	8001922 <prvInitialiseTCBVariables+0x3a>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 800191c:	f04f 0304 	mov.w	r3, #4
 8001920:	607b      	str	r3, [r7, #4]
	}

	pxTCB->uxPriority = uxPriority;
 8001922:	68fb      	ldr	r3, [r7, #12]
 8001924:	687a      	ldr	r2, [r7, #4]
 8001926:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
 8001928:	68fb      	ldr	r3, [r7, #12]
 800192a:	687a      	ldr	r2, [r7, #4]
 800192c:	645a      	str	r2, [r3, #68]	; 0x44
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 800192e:	68fb      	ldr	r3, [r7, #12]
 8001930:	f103 0304 	add.w	r3, r3, #4
 8001934:	4618      	mov	r0, r3
 8001936:	f000 f90b 	bl	8001b50 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 800193a:	68fb      	ldr	r3, [r7, #12]
 800193c:	f103 0318 	add.w	r3, r3, #24
 8001940:	4618      	mov	r0, r3
 8001942:	f000 f905 	bl	8001b50 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 8001946:	68fb      	ldr	r3, [r7, #12]
 8001948:	68fa      	ldr	r2, [r7, #12]
 800194a:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 800194c:	687b      	ldr	r3, [r7, #4]
 800194e:	f1c3 0205 	rsb	r2, r3, #5
 8001952:	68fb      	ldr	r3, [r7, #12]
 8001954:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 8001956:	68fb      	ldr	r3, [r7, #12]
 8001958:	68fa      	ldr	r2, [r7, #12]
 800195a:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif

	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
	{
		pxTCB->pxTaskTag = NULL;
 800195c:	68fb      	ldr	r3, [r7, #12]
 800195e:	f04f 0200 	mov.w	r2, #0
 8001962:	649a      	str	r2, [r3, #72]	; 0x48
	}
	#endif

	#if ( configGENERATE_RUN_TIME_STATS == 1 )
	{
		pxTCB->ulRunTimeCounter = 0UL;
 8001964:	68fb      	ldr	r3, [r7, #12]
 8001966:	f04f 0200 	mov.w	r2, #0
 800196a:	64da      	str	r2, [r3, #76]	; 0x4c
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
 800196c:	f107 0710 	add.w	r7, r7, #16
 8001970:	46bd      	mov	sp, r7
 8001972:	bd80      	pop	{r7, pc}

08001974 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
 8001974:	b580      	push	{r7, lr}
 8001976:	b082      	sub	sp, #8
 8001978:	af00      	add	r7, sp, #0
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 800197a:	f04f 0300 	mov.w	r3, #0
 800197e:	607b      	str	r3, [r7, #4]
 8001980:	e010      	b.n	80019a4 <prvInitialiseTaskLists+0x30>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 8001982:	687a      	ldr	r2, [r7, #4]
 8001984:	4613      	mov	r3, r2
 8001986:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800198a:	189b      	adds	r3, r3, r2
 800198c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001990:	461a      	mov	r2, r3
 8001992:	4b12      	ldr	r3, [pc, #72]	; (80019dc <prvInitialiseTaskLists+0x68>)
 8001994:	18d3      	adds	r3, r2, r3
 8001996:	4618      	mov	r0, r3
 8001998:	f000 f8b6 	bl	8001b08 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 800199c:	687b      	ldr	r3, [r7, #4]
 800199e:	f103 0301 	add.w	r3, r3, #1
 80019a2:	607b      	str	r3, [r7, #4]
 80019a4:	687b      	ldr	r3, [r7, #4]
 80019a6:	2b04      	cmp	r3, #4
 80019a8:	d9eb      	bls.n	8001982 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 80019aa:	480d      	ldr	r0, [pc, #52]	; (80019e0 <prvInitialiseTaskLists+0x6c>)
 80019ac:	f000 f8ac 	bl	8001b08 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 80019b0:	480c      	ldr	r0, [pc, #48]	; (80019e4 <prvInitialiseTaskLists+0x70>)
 80019b2:	f000 f8a9 	bl	8001b08 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
 80019b6:	480c      	ldr	r0, [pc, #48]	; (80019e8 <prvInitialiseTaskLists+0x74>)
 80019b8:	f000 f8a6 	bl	8001b08 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 80019bc:	480b      	ldr	r0, [pc, #44]	; (80019ec <prvInitialiseTaskLists+0x78>)
 80019be:	f000 f8a3 	bl	8001b08 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
 80019c2:	480b      	ldr	r0, [pc, #44]	; (80019f0 <prvInitialiseTaskLists+0x7c>)
 80019c4:	f000 f8a0 	bl	8001b08 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 80019c8:	4b0a      	ldr	r3, [pc, #40]	; (80019f4 <prvInitialiseTaskLists+0x80>)
 80019ca:	4a05      	ldr	r2, [pc, #20]	; (80019e0 <prvInitialiseTaskLists+0x6c>)
 80019cc:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 80019ce:	4b0a      	ldr	r3, [pc, #40]	; (80019f8 <prvInitialiseTaskLists+0x84>)
 80019d0:	4a04      	ldr	r2, [pc, #16]	; (80019e4 <prvInitialiseTaskLists+0x70>)
 80019d2:	601a      	str	r2, [r3, #0]
}
 80019d4:	f107 0708 	add.w	r7, r7, #8
 80019d8:	46bd      	mov	sp, r7
 80019da:	bd80      	pop	{r7, pc}
 80019dc:	2000069c 	.word	0x2000069c
 80019e0:	20000700 	.word	0x20000700
 80019e4:	20000714 	.word	0x20000714
 80019e8:	20000730 	.word	0x20000730
 80019ec:	20000744 	.word	0x20000744
 80019f0:	2000075c 	.word	0x2000075c
 80019f4:	20000728 	.word	0x20000728
 80019f8:	2000072c 	.word	0x2000072c

080019fc <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 80019fc:	b580      	push	{r7, lr}
 80019fe:	b082      	sub	sp, #8
 8001a00:	af00      	add	r7, sp, #0
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 8001a02:	4b19      	ldr	r3, [pc, #100]	; (8001a68 <prvCheckTasksWaitingTermination+0x6c>)
 8001a04:	681b      	ldr	r3, [r3, #0]
 8001a06:	2b00      	cmp	r3, #0
 8001a08:	d02a      	beq.n	8001a60 <prvCheckTasksWaitingTermination+0x64>
		{
			vTaskSuspendAll();
 8001a0a:	f7ff fdb7 	bl	800157c <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 8001a0e:	4b17      	ldr	r3, [pc, #92]	; (8001a6c <prvCheckTasksWaitingTermination+0x70>)
 8001a10:	681b      	ldr	r3, [r3, #0]
 8001a12:	2b00      	cmp	r3, #0
 8001a14:	bf14      	ite	ne
 8001a16:	2300      	movne	r3, #0
 8001a18:	2301      	moveq	r3, #1
 8001a1a:	607b      	str	r3, [r7, #4]
			xTaskResumeAll();
 8001a1c:	f7ff fdbc 	bl	8001598 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 8001a20:	687b      	ldr	r3, [r7, #4]
 8001a22:	2b00      	cmp	r3, #0
 8001a24:	d11c      	bne.n	8001a60 <prvCheckTasksWaitingTermination+0x64>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
 8001a26:	f000 f977 	bl	8001d18 <vPortEnterCritical>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 8001a2a:	4b10      	ldr	r3, [pc, #64]	; (8001a6c <prvCheckTasksWaitingTermination+0x70>)
 8001a2c:	68db      	ldr	r3, [r3, #12]
 8001a2e:	68db      	ldr	r3, [r3, #12]
 8001a30:	603b      	str	r3, [r7, #0]
					vListRemove( &( pxTCB->xGenericListItem ) );
 8001a32:	683b      	ldr	r3, [r7, #0]
 8001a34:	f103 0304 	add.w	r3, r3, #4
 8001a38:	4618      	mov	r0, r3
 8001a3a:	f000 f8bf 	bl	8001bbc <vListRemove>
					--uxCurrentNumberOfTasks;
 8001a3e:	4b0c      	ldr	r3, [pc, #48]	; (8001a70 <prvCheckTasksWaitingTermination+0x74>)
 8001a40:	681b      	ldr	r3, [r3, #0]
 8001a42:	f103 32ff 	add.w	r2, r3, #4294967295
 8001a46:	4b0a      	ldr	r3, [pc, #40]	; (8001a70 <prvCheckTasksWaitingTermination+0x74>)
 8001a48:	601a      	str	r2, [r3, #0]
					--uxTasksDeleted;
 8001a4a:	4b07      	ldr	r3, [pc, #28]	; (8001a68 <prvCheckTasksWaitingTermination+0x6c>)
 8001a4c:	681b      	ldr	r3, [r3, #0]
 8001a4e:	f103 32ff 	add.w	r2, r3, #4294967295
 8001a52:	4b05      	ldr	r3, [pc, #20]	; (8001a68 <prvCheckTasksWaitingTermination+0x6c>)
 8001a54:	601a      	str	r2, [r3, #0]
				}
				taskEXIT_CRITICAL();
 8001a56:	f000 f971 	bl	8001d3c <vPortExitCritical>

				prvDeleteTCB( pxTCB );
 8001a5a:	6838      	ldr	r0, [r7, #0]
 8001a5c:	f000 f844 	bl	8001ae8 <prvDeleteTCB>
			}
		}
	}
	#endif
}
 8001a60:	f107 0708 	add.w	r7, r7, #8
 8001a64:	46bd      	mov	sp, r7
 8001a66:	bd80      	pop	{r7, pc}
 8001a68:	20000758 	.word	0x20000758
 8001a6c:	20000744 	.word	0x20000744
 8001a70:	20000774 	.word	0x20000774

08001a74 <prvAllocateTCBAndStack>:
	}
}
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
 8001a74:	b580      	push	{r7, lr}
 8001a76:	b084      	sub	sp, #16
 8001a78:	af00      	add	r7, sp, #0
 8001a7a:	4603      	mov	r3, r0
 8001a7c:	6039      	str	r1, [r7, #0]
 8001a7e:	80fb      	strh	r3, [r7, #6]
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 8001a80:	f04f 0050 	mov.w	r0, #80	; 0x50
 8001a84:	f7fe fbc0 	bl	8000208 <malloc>
 8001a88:	4603      	mov	r3, r0
 8001a8a:	60fb      	str	r3, [r7, #12]

	if( pxNewTCB != NULL )
 8001a8c:	68fb      	ldr	r3, [r7, #12]
 8001a8e:	2b00      	cmp	r3, #0
 8001a90:	d023      	beq.n	8001ada <prvAllocateTCBAndStack+0x66>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
 8001a92:	683b      	ldr	r3, [r7, #0]
 8001a94:	2b00      	cmp	r3, #0
 8001a96:	d107      	bne.n	8001aa8 <prvAllocateTCBAndStack+0x34>
 8001a98:	88fb      	ldrh	r3, [r7, #6]
 8001a9a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001a9e:	4618      	mov	r0, r3
 8001aa0:	f7fe fbb2 	bl	8000208 <malloc>
 8001aa4:	4603      	mov	r3, r0
 8001aa6:	e000      	b.n	8001aaa <prvAllocateTCBAndStack+0x36>
 8001aa8:	683b      	ldr	r3, [r7, #0]
 8001aaa:	68fa      	ldr	r2, [r7, #12]
 8001aac:	6313      	str	r3, [r2, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
 8001aae:	68fb      	ldr	r3, [r7, #12]
 8001ab0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001ab2:	2b00      	cmp	r3, #0
 8001ab4:	d106      	bne.n	8001ac4 <prvAllocateTCBAndStack+0x50>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
 8001ab6:	68f8      	ldr	r0, [r7, #12]
 8001ab8:	f7fe fbae 	bl	8000218 <free>
			pxNewTCB = NULL;
 8001abc:	f04f 0300 	mov.w	r3, #0
 8001ac0:	60fb      	str	r3, [r7, #12]
 8001ac2:	e00a      	b.n	8001ada <prvAllocateTCBAndStack+0x66>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
 8001ac4:	68fb      	ldr	r3, [r7, #12]
 8001ac6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001ac8:	88fb      	ldrh	r3, [r7, #6]
 8001aca:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001ace:	4610      	mov	r0, r2
 8001ad0:	f04f 01a5 	mov.w	r1, #165	; 0xa5
 8001ad4:	461a      	mov	r2, r3
 8001ad6:	f7fe fe65 	bl	80007a4 <memset>
		}
	}

	return pxNewTCB;
 8001ada:	68fb      	ldr	r3, [r7, #12]
}
 8001adc:	4618      	mov	r0, r3
 8001ade:	f107 0710 	add.w	r7, r7, #16
 8001ae2:	46bd      	mov	sp, r7
 8001ae4:	bd80      	pop	{r7, pc}
 8001ae6:	bf00      	nop

08001ae8 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
 8001ae8:	b580      	push	{r7, lr}
 8001aea:	b082      	sub	sp, #8
 8001aec:	af00      	add	r7, sp, #0
 8001aee:	6078      	str	r0, [r7, #4]
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
 8001af0:	687b      	ldr	r3, [r7, #4]
 8001af2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001af4:	4618      	mov	r0, r3
 8001af6:	f7fe fb8f 	bl	8000218 <free>
		vPortFree( pxTCB );
 8001afa:	6878      	ldr	r0, [r7, #4]
 8001afc:	f7fe fb8c 	bl	8000218 <free>
	}
 8001b00:	f107 0708 	add.w	r7, r7, #8
 8001b04:	46bd      	mov	sp, r7
 8001b06:	bd80      	pop	{r7, pc}

08001b08 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
 8001b08:	b480      	push	{r7}
 8001b0a:	b083      	sub	sp, #12
 8001b0c:	af00      	add	r7, sp, #0
 8001b0e:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 8001b10:	687b      	ldr	r3, [r7, #4]
 8001b12:	f103 0308 	add.w	r3, r3, #8
 8001b16:	461a      	mov	r2, r3
 8001b18:	687b      	ldr	r3, [r7, #4]
 8001b1a:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8001b1c:	687b      	ldr	r3, [r7, #4]
 8001b1e:	f04f 32ff 	mov.w	r2, #4294967295
 8001b22:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
 8001b24:	687b      	ldr	r3, [r7, #4]
 8001b26:	f103 0308 	add.w	r3, r3, #8
 8001b2a:	461a      	mov	r2, r3
 8001b2c:	687b      	ldr	r3, [r7, #4]
 8001b2e:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
 8001b30:	687b      	ldr	r3, [r7, #4]
 8001b32:	f103 0308 	add.w	r3, r3, #8
 8001b36:	461a      	mov	r2, r3
 8001b38:	687b      	ldr	r3, [r7, #4]
 8001b3a:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
 8001b3c:	687b      	ldr	r3, [r7, #4]
 8001b3e:	f04f 0200 	mov.w	r2, #0
 8001b42:	601a      	str	r2, [r3, #0]
}
 8001b44:	f107 070c 	add.w	r7, r7, #12
 8001b48:	46bd      	mov	sp, r7
 8001b4a:	bc80      	pop	{r7}
 8001b4c:	4770      	bx	lr
 8001b4e:	bf00      	nop

08001b50 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
 8001b50:	b480      	push	{r7}
 8001b52:	b083      	sub	sp, #12
 8001b54:	af00      	add	r7, sp, #0
 8001b56:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8001b58:	687b      	ldr	r3, [r7, #4]
 8001b5a:	f04f 0200 	mov.w	r2, #0
 8001b5e:	611a      	str	r2, [r3, #16]
}
 8001b60:	f107 070c 	add.w	r7, r7, #12
 8001b64:	46bd      	mov	sp, r7
 8001b66:	bc80      	pop	{r7}
 8001b68:	4770      	bx	lr
 8001b6a:	bf00      	nop

08001b6c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
 8001b6c:	b480      	push	{r7}
 8001b6e:	b085      	sub	sp, #20
 8001b70:	af00      	add	r7, sp, #0
 8001b72:	6078      	str	r0, [r7, #4]
 8001b74:	6039      	str	r1, [r7, #0]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 8001b76:	687b      	ldr	r3, [r7, #4]
 8001b78:	685b      	ldr	r3, [r3, #4]
 8001b7a:	60fb      	str	r3, [r7, #12]

	pxNewListItem->pxNext = pxIndex->pxNext;
 8001b7c:	68fb      	ldr	r3, [r7, #12]
 8001b7e:	685a      	ldr	r2, [r3, #4]
 8001b80:	683b      	ldr	r3, [r7, #0]
 8001b82:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
 8001b84:	687b      	ldr	r3, [r7, #4]
 8001b86:	685a      	ldr	r2, [r3, #4]
 8001b88:	683b      	ldr	r3, [r7, #0]
 8001b8a:	609a      	str	r2, [r3, #8]
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 8001b8c:	68fb      	ldr	r3, [r7, #12]
 8001b8e:	685b      	ldr	r3, [r3, #4]
 8001b90:	683a      	ldr	r2, [r7, #0]
 8001b92:	609a      	str	r2, [r3, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 8001b94:	683a      	ldr	r2, [r7, #0]
 8001b96:	68fb      	ldr	r3, [r7, #12]
 8001b98:	605a      	str	r2, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 8001b9a:	683a      	ldr	r2, [r7, #0]
 8001b9c:	687b      	ldr	r3, [r7, #4]
 8001b9e:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8001ba0:	683b      	ldr	r3, [r7, #0]
 8001ba2:	687a      	ldr	r2, [r7, #4]
 8001ba4:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 8001ba6:	687b      	ldr	r3, [r7, #4]
 8001ba8:	681b      	ldr	r3, [r3, #0]
 8001baa:	f103 0201 	add.w	r2, r3, #1
 8001bae:	687b      	ldr	r3, [r7, #4]
 8001bb0:	601a      	str	r2, [r3, #0]
}
 8001bb2:	f107 0714 	add.w	r7, r7, #20
 8001bb6:	46bd      	mov	sp, r7
 8001bb8:	bc80      	pop	{r7}
 8001bba:	4770      	bx	lr

08001bbc <vListRemove>:
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
 8001bbc:	b480      	push	{r7}
 8001bbe:	b085      	sub	sp, #20
 8001bc0:	af00      	add	r7, sp, #0
 8001bc2:	6078      	str	r0, [r7, #4]
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8001bc4:	687b      	ldr	r3, [r7, #4]
 8001bc6:	685b      	ldr	r3, [r3, #4]
 8001bc8:	687a      	ldr	r2, [r7, #4]
 8001bca:	6892      	ldr	r2, [r2, #8]
 8001bcc:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8001bce:	687b      	ldr	r3, [r7, #4]
 8001bd0:	689b      	ldr	r3, [r3, #8]
 8001bd2:	687a      	ldr	r2, [r7, #4]
 8001bd4:	6852      	ldr	r2, [r2, #4]
 8001bd6:	605a      	str	r2, [r3, #4]
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 8001bd8:	687b      	ldr	r3, [r7, #4]
 8001bda:	691b      	ldr	r3, [r3, #16]
 8001bdc:	60fb      	str	r3, [r7, #12]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8001bde:	68fb      	ldr	r3, [r7, #12]
 8001be0:	685a      	ldr	r2, [r3, #4]
 8001be2:	687b      	ldr	r3, [r7, #4]
 8001be4:	429a      	cmp	r2, r3
 8001be6:	d103      	bne.n	8001bf0 <vListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8001be8:	687b      	ldr	r3, [r7, #4]
 8001bea:	689a      	ldr	r2, [r3, #8]
 8001bec:	68fb      	ldr	r3, [r7, #12]
 8001bee:	605a      	str	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
 8001bf0:	687b      	ldr	r3, [r7, #4]
 8001bf2:	f04f 0200 	mov.w	r2, #0
 8001bf6:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
 8001bf8:	68fb      	ldr	r3, [r7, #12]
 8001bfa:	681b      	ldr	r3, [r3, #0]
 8001bfc:	f103 32ff 	add.w	r2, r3, #4294967295
 8001c00:	68fb      	ldr	r3, [r7, #12]
 8001c02:	601a      	str	r2, [r3, #0]
}
 8001c04:	f107 0714 	add.w	r7, r7, #20
 8001c08:	46bd      	mov	sp, r7
 8001c0a:	bc80      	pop	{r7}
 8001c0c:	4770      	bx	lr
 8001c0e:	bf00      	nop

08001c10 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
 8001c10:	b480      	push	{r7}
 8001c12:	b085      	sub	sp, #20
 8001c14:	af00      	add	r7, sp, #0
 8001c16:	60f8      	str	r0, [r7, #12]
 8001c18:	60b9      	str	r1, [r7, #8]
 8001c1a:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */

	/* Offset added to account for the way the MCU uses the stack on entry/exit
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;
 8001c1c:	68fb      	ldr	r3, [r7, #12]
 8001c1e:	f1a3 0304 	sub.w	r3, r3, #4
 8001c22:	60fb      	str	r3, [r7, #12]

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8001c24:	68fb      	ldr	r3, [r7, #12]
 8001c26:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8001c2a:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 8001c2c:	68fb      	ldr	r3, [r7, #12]
 8001c2e:	f1a3 0304 	sub.w	r3, r3, #4
 8001c32:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
 8001c34:	68ba      	ldr	r2, [r7, #8]
 8001c36:	68fb      	ldr	r3, [r7, #12]
 8001c38:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 8001c3a:	68fb      	ldr	r3, [r7, #12]
 8001c3c:	f1a3 0304 	sub.w	r3, r3, #4
 8001c40:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = 0;	/* LR */
 8001c42:	68fb      	ldr	r3, [r7, #12]
 8001c44:	f04f 0200 	mov.w	r2, #0
 8001c48:	601a      	str	r2, [r3, #0]

	/* Save code space by skipping register initialisation. */
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
 8001c4a:	68fb      	ldr	r3, [r7, #12]
 8001c4c:	f1a3 0314 	sub.w	r3, r3, #20
 8001c50:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
 8001c52:	687a      	ldr	r2, [r7, #4]
 8001c54:	68fb      	ldr	r3, [r7, #12]
 8001c56:	601a      	str	r2, [r3, #0]

	/* A save method is being used that requires each task to maintain its
	own exec return value. */
	pxTopOfStack--;
 8001c58:	68fb      	ldr	r3, [r7, #12]
 8001c5a:	f1a3 0304 	sub.w	r3, r3, #4
 8001c5e:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
 8001c60:	68fb      	ldr	r3, [r7, #12]
 8001c62:	f06f 0202 	mvn.w	r2, #2
 8001c66:	601a      	str	r2, [r3, #0]

	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
 8001c68:	68fb      	ldr	r3, [r7, #12]
 8001c6a:	f1a3 0320 	sub.w	r3, r3, #32
 8001c6e:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
 8001c70:	68fb      	ldr	r3, [r7, #12]
}
 8001c72:	4618      	mov	r0, r3
 8001c74:	f107 0714 	add.w	r7, r7, #20
 8001c78:	46bd      	mov	sp, r7
 8001c7a:	bc80      	pop	{r7}
 8001c7c:	4770      	bx	lr
 8001c7e:	bf00      	nop

08001c80 <SVC_Handler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8001c80:	4b05      	ldr	r3, [pc, #20]	; (8001c98 <pxCurrentTCBConst2>)
 8001c82:	6819      	ldr	r1, [r3, #0]
 8001c84:	6808      	ldr	r0, [r1, #0]
 8001c86:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001c8a:	f380 8809 	msr	PSP, r0
 8001c8e:	f04f 0000 	mov.w	r0, #0
 8001c92:	f380 8811 	msr	BASEPRI, r0
 8001c96:	4770      	bx	lr

08001c98 <pxCurrentTCBConst2>:
 8001c98:	20000698 	.word	0x20000698

08001c9c <vPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void vPortStartFirstTask( void )
{
	__asm volatile(
 8001c9c:	4803      	ldr	r0, [pc, #12]	; (8001cac <vPortStartFirstTask+0x10>)
 8001c9e:	6800      	ldr	r0, [r0, #0]
 8001ca0:	6800      	ldr	r0, [r0, #0]
 8001ca2:	f380 8808 	msr	MSP, r0
 8001ca6:	b662      	cpsie	i
 8001ca8:	df00      	svc	0
 8001caa:	bf00      	nop
 8001cac:	e000ed08 	.word	0xe000ed08

08001cb0 <xPortStartScheduler>:

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
 8001cb0:	b580      	push	{r7, lr}
 8001cb2:	af00      	add	r7, sp, #0
	/* Make PendSV and SysTick the lowest priority interrupts. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 8001cb4:	4b0f      	ldr	r3, [pc, #60]	; (8001cf4 <xPortStartScheduler+0x44>)
 8001cb6:	4a0f      	ldr	r2, [pc, #60]	; (8001cf4 <xPortStartScheduler+0x44>)
 8001cb8:	6812      	ldr	r2, [r2, #0]
 8001cba:	f442 027f 	orr.w	r2, r2, #16711680	; 0xff0000
 8001cbe:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 8001cc0:	4b0c      	ldr	r3, [pc, #48]	; (8001cf4 <xPortStartScheduler+0x44>)
 8001cc2:	4a0c      	ldr	r2, [pc, #48]	; (8001cf4 <xPortStartScheduler+0x44>)
 8001cc4:	6812      	ldr	r2, [r2, #0]
 8001cc6:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000
 8001cca:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
 8001ccc:	f000 f88e 	bl	8001dec <prvSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8001cd0:	4b09      	ldr	r3, [pc, #36]	; (8001cf8 <xPortStartScheduler+0x48>)
 8001cd2:	f04f 0200 	mov.w	r2, #0
 8001cd6:	601a      	str	r2, [r3, #0]

	/* Ensure the VFP is enabled - it should be anyway. */
	vPortEnableVFP();
 8001cd8:	f000 f8a4 	bl	8001e24 <vPortEnableVFP>

	/* Lazy save always. */
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 8001cdc:	4b07      	ldr	r3, [pc, #28]	; (8001cfc <xPortStartScheduler+0x4c>)
 8001cde:	4a07      	ldr	r2, [pc, #28]	; (8001cfc <xPortStartScheduler+0x4c>)
 8001ce0:	6812      	ldr	r2, [r2, #0]
 8001ce2:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
 8001ce6:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	vPortStartFirstTask();
 8001ce8:	f7ff ffd8 	bl	8001c9c <vPortStartFirstTask>

	/* Should not get here! */
	return 0;
 8001cec:	f04f 0300 	mov.w	r3, #0
}
 8001cf0:	4618      	mov	r0, r3
 8001cf2:	bd80      	pop	{r7, pc}
 8001cf4:	e000ed20 	.word	0xe000ed20
 8001cf8:	20000530 	.word	0x20000530
 8001cfc:	e000ef34 	.word	0xe000ef34

08001d00 <vPortYieldFromISR>:
	is nothing to return to.  */
}
/*-----------------------------------------------------------*/

void vPortYieldFromISR( void )
{
 8001d00:	b480      	push	{r7}
 8001d02:	af00      	add	r7, sp, #0
	/* Set a PendSV to request a context switch. */
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 8001d04:	4b03      	ldr	r3, [pc, #12]	; (8001d14 <vPortYieldFromISR+0x14>)
 8001d06:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001d0a:	601a      	str	r2, [r3, #0]
}
 8001d0c:	46bd      	mov	sp, r7
 8001d0e:	bc80      	pop	{r7}
 8001d10:	4770      	bx	lr
 8001d12:	bf00      	nop
 8001d14:	e000ed04 	.word	0xe000ed04

08001d18 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 8001d18:	b480      	push	{r7}
 8001d1a:	af00      	add	r7, sp, #0
	portDISABLE_INTERRUPTS();
 8001d1c:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8001d20:	f380 8811 	msr	BASEPRI, r0
	uxCriticalNesting++;
 8001d24:	4b04      	ldr	r3, [pc, #16]	; (8001d38 <vPortEnterCritical+0x20>)
 8001d26:	681b      	ldr	r3, [r3, #0]
 8001d28:	f103 0201 	add.w	r2, r3, #1
 8001d2c:	4b02      	ldr	r3, [pc, #8]	; (8001d38 <vPortEnterCritical+0x20>)
 8001d2e:	601a      	str	r2, [r3, #0]
}
 8001d30:	46bd      	mov	sp, r7
 8001d32:	bc80      	pop	{r7}
 8001d34:	4770      	bx	lr
 8001d36:	bf00      	nop
 8001d38:	20000530 	.word	0x20000530

08001d3c <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
 8001d3c:	b480      	push	{r7}
 8001d3e:	af00      	add	r7, sp, #0
	uxCriticalNesting--;
 8001d40:	4b08      	ldr	r3, [pc, #32]	; (8001d64 <vPortExitCritical+0x28>)
 8001d42:	681b      	ldr	r3, [r3, #0]
 8001d44:	f103 32ff 	add.w	r2, r3, #4294967295
 8001d48:	4b06      	ldr	r3, [pc, #24]	; (8001d64 <vPortExitCritical+0x28>)
 8001d4a:	601a      	str	r2, [r3, #0]
	if( uxCriticalNesting == 0 )
 8001d4c:	4b05      	ldr	r3, [pc, #20]	; (8001d64 <vPortExitCritical+0x28>)
 8001d4e:	681b      	ldr	r3, [r3, #0]
 8001d50:	2b00      	cmp	r3, #0
 8001d52:	d103      	bne.n	8001d5c <vPortExitCritical+0x20>
	{
		portENABLE_INTERRUPTS();
 8001d54:	f04f 0000 	mov.w	r0, #0
 8001d58:	f380 8811 	msr	BASEPRI, r0
	}
}
 8001d5c:	46bd      	mov	sp, r7
 8001d5e:	bc80      	pop	{r7}
 8001d60:	4770      	bx	lr
 8001d62:	bf00      	nop
 8001d64:	20000530 	.word	0x20000530

08001d68 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8001d68:	f3ef 8009 	mrs	r0, PSP
 8001d6c:	4b11      	ldr	r3, [pc, #68]	; (8001db4 <pxCurrentTCBConst>)
 8001d6e:	681a      	ldr	r2, [r3, #0]
 8001d70:	f01e 0f10 	tst.w	lr, #16
 8001d74:	bf08      	it	eq
 8001d76:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8001d7a:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001d7e:	6010      	str	r0, [r2, #0]
 8001d80:	e92d 4008 	stmdb	sp!, {r3, lr}
 8001d84:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8001d88:	f380 8811 	msr	BASEPRI, r0
 8001d8c:	f7ff fd2c 	bl	80017e8 <vTaskSwitchContext>
 8001d90:	f04f 0000 	mov.w	r0, #0
 8001d94:	f380 8811 	msr	BASEPRI, r0
 8001d98:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8001d9c:	6819      	ldr	r1, [r3, #0]
 8001d9e:	6808      	ldr	r0, [r1, #0]
 8001da0:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001da4:	f01e 0f10 	tst.w	lr, #16
 8001da8:	bf08      	it	eq
 8001daa:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 8001dae:	f380 8809 	msr	PSP, r0
 8001db2:	4770      	bx	lr

08001db4 <pxCurrentTCBConst>:
 8001db4:	20000698 	.word	0x20000698

08001db8 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8001db8:	b580      	push	{r7, lr}
 8001dba:	b082      	sub	sp, #8
 8001dbc:	af00      	add	r7, sp, #0
unsigned long ulDummy;

	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
		*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 8001dbe:	4b0a      	ldr	r3, [pc, #40]	; (8001de8 <SysTick_Handler+0x30>)
 8001dc0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001dc4:	601a      	str	r2, [r3, #0]
	#endif

	ulDummy = portSET_INTERRUPT_MASK_FROM_ISR();
 8001dc6:	f04f 0300 	mov.w	r3, #0
 8001dca:	607b      	str	r3, [r7, #4]
 8001dcc:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8001dd0:	f380 8811 	msr	BASEPRI, r0
	{
		vTaskIncrementTick();
 8001dd4:	f7ff fc6a 	bl	80016ac <vTaskIncrementTick>
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulDummy );
 8001dd8:	f04f 0000 	mov.w	r0, #0
 8001ddc:	f380 8811 	msr	BASEPRI, r0
}
 8001de0:	f107 0708 	add.w	r7, r7, #8
 8001de4:	46bd      	mov	sp, r7
 8001de6:	bd80      	pop	{r7, pc}
 8001de8:	e000ed04 	.word	0xe000ed04

08001dec <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
 8001dec:	b480      	push	{r7}
 8001dee:	af00      	add	r7, sp, #0
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8001df0:	4b08      	ldr	r3, [pc, #32]	; (8001e14 <prvSetupTimerInterrupt+0x28>)
 8001df2:	4a09      	ldr	r2, [pc, #36]	; (8001e18 <prvSetupTimerInterrupt+0x2c>)
 8001df4:	6811      	ldr	r1, [r2, #0]
 8001df6:	4a09      	ldr	r2, [pc, #36]	; (8001e1c <prvSetupTimerInterrupt+0x30>)
 8001df8:	fba2 0201 	umull	r0, r2, r2, r1
 8001dfc:	ea4f 1292 	mov.w	r2, r2, lsr #6
 8001e00:	f102 32ff 	add.w	r2, r2, #4294967295
 8001e04:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 8001e06:	4b06      	ldr	r3, [pc, #24]	; (8001e20 <prvSetupTimerInterrupt+0x34>)
 8001e08:	f04f 0207 	mov.w	r2, #7
 8001e0c:	601a      	str	r2, [r3, #0]
}
 8001e0e:	46bd      	mov	sp, r7
 8001e10:	bc80      	pop	{r7}
 8001e12:	4770      	bx	lr
 8001e14:	e000e014 	.word	0xe000e014
 8001e18:	20000524 	.word	0x20000524
 8001e1c:	10624dd3 	.word	0x10624dd3
 8001e20:	e000e010 	.word	0xe000e010

08001e24 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 8001e24:	f8df 000c 	ldr.w	r0, [pc, #12]	; 8001e34 <vPortEnableVFP+0x10>
 8001e28:	6801      	ldr	r1, [r0, #0]
 8001e2a:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8001e2e:	6001      	str	r1, [r0, #0]
 8001e30:	4770      	bx	lr
 8001e32:	0000      	.short	0x0000
 8001e34:	e000ed88 	.word	0xe000ed88

08001e38 <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8001e38:	b480      	push	{r7}
 8001e3a:	b087      	sub	sp, #28
 8001e3c:	af00      	add	r7, sp, #0
 8001e3e:	6078      	str	r0, [r7, #4]
 8001e40:	6039      	str	r1, [r7, #0]
  uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;
 8001e42:	f04f 0300 	mov.w	r3, #0
 8001e46:	617b      	str	r3, [r7, #20]
 8001e48:	f04f 0300 	mov.w	r3, #0
 8001e4c:	613b      	str	r3, [r7, #16]
 8001e4e:	f04f 0300 	mov.w	r3, #0
 8001e52:	60fb      	str	r3, [r7, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8001e54:	f04f 0300 	mov.w	r3, #0
 8001e58:	617b      	str	r3, [r7, #20]
 8001e5a:	e087      	b.n	8001f6c <GPIO_Init+0x134>
  {
    pos = ((uint32_t)0x01) << pinpos;
 8001e5c:	697b      	ldr	r3, [r7, #20]
 8001e5e:	f04f 0201 	mov.w	r2, #1
 8001e62:	fa02 f303 	lsl.w	r3, r2, r3
 8001e66:	613b      	str	r3, [r7, #16]
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8001e68:	683b      	ldr	r3, [r7, #0]
 8001e6a:	681a      	ldr	r2, [r3, #0]
 8001e6c:	693b      	ldr	r3, [r7, #16]
 8001e6e:	ea02 0303 	and.w	r3, r2, r3
 8001e72:	60fb      	str	r3, [r7, #12]

    if (currentpin == pos)
 8001e74:	68fa      	ldr	r2, [r7, #12]
 8001e76:	693b      	ldr	r3, [r7, #16]
 8001e78:	429a      	cmp	r2, r3
 8001e7a:	d173      	bne.n	8001f64 <GPIO_Init+0x12c>
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8001e7c:	687b      	ldr	r3, [r7, #4]
 8001e7e:	681a      	ldr	r2, [r3, #0]
 8001e80:	697b      	ldr	r3, [r7, #20]
 8001e82:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8001e86:	f04f 0103 	mov.w	r1, #3
 8001e8a:	fa01 f303 	lsl.w	r3, r1, r3
 8001e8e:	ea6f 0303 	mvn.w	r3, r3
 8001e92:	401a      	ands	r2, r3
 8001e94:	687b      	ldr	r3, [r7, #4]
 8001e96:	601a      	str	r2, [r3, #0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8001e98:	687b      	ldr	r3, [r7, #4]
 8001e9a:	681a      	ldr	r2, [r3, #0]
 8001e9c:	683b      	ldr	r3, [r7, #0]
 8001e9e:	791b      	ldrb	r3, [r3, #4]
 8001ea0:	4619      	mov	r1, r3
 8001ea2:	697b      	ldr	r3, [r7, #20]
 8001ea4:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8001ea8:	fa01 f303 	lsl.w	r3, r1, r3
 8001eac:	431a      	orrs	r2, r3
 8001eae:	687b      	ldr	r3, [r7, #4]
 8001eb0:	601a      	str	r2, [r3, #0]

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8001eb2:	683b      	ldr	r3, [r7, #0]
 8001eb4:	791b      	ldrb	r3, [r3, #4]
 8001eb6:	2b01      	cmp	r3, #1
 8001eb8:	d003      	beq.n	8001ec2 <GPIO_Init+0x8a>
 8001eba:	683b      	ldr	r3, [r7, #0]
 8001ebc:	791b      	ldrb	r3, [r3, #4]
 8001ebe:	2b02      	cmp	r3, #2
 8001ec0:	d134      	bne.n	8001f2c <GPIO_Init+0xf4>
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 8001ec2:	687b      	ldr	r3, [r7, #4]
 8001ec4:	689a      	ldr	r2, [r3, #8]
 8001ec6:	697b      	ldr	r3, [r7, #20]
 8001ec8:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8001ecc:	f04f 0103 	mov.w	r1, #3
 8001ed0:	fa01 f303 	lsl.w	r3, r1, r3
 8001ed4:	ea6f 0303 	mvn.w	r3, r3
 8001ed8:	401a      	ands	r2, r3
 8001eda:	687b      	ldr	r3, [r7, #4]
 8001edc:	609a      	str	r2, [r3, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 8001ede:	687b      	ldr	r3, [r7, #4]
 8001ee0:	689a      	ldr	r2, [r3, #8]
 8001ee2:	683b      	ldr	r3, [r7, #0]
 8001ee4:	795b      	ldrb	r3, [r3, #5]
 8001ee6:	4619      	mov	r1, r3
 8001ee8:	697b      	ldr	r3, [r7, #20]
 8001eea:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8001eee:	fa01 f303 	lsl.w	r3, r1, r3
 8001ef2:	431a      	orrs	r2, r3
 8001ef4:	687b      	ldr	r3, [r7, #4]
 8001ef6:	609a      	str	r2, [r3, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 8001ef8:	687b      	ldr	r3, [r7, #4]
 8001efa:	685a      	ldr	r2, [r3, #4]
 8001efc:	697b      	ldr	r3, [r7, #20]
 8001efe:	b29b      	uxth	r3, r3
 8001f00:	f04f 0101 	mov.w	r1, #1
 8001f04:	fa01 f303 	lsl.w	r3, r1, r3
 8001f08:	ea6f 0303 	mvn.w	r3, r3
 8001f0c:	401a      	ands	r2, r3
 8001f0e:	687b      	ldr	r3, [r7, #4]
 8001f10:	605a      	str	r2, [r3, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 8001f12:	687b      	ldr	r3, [r7, #4]
 8001f14:	685a      	ldr	r2, [r3, #4]
 8001f16:	683b      	ldr	r3, [r7, #0]
 8001f18:	799b      	ldrb	r3, [r3, #6]
 8001f1a:	4619      	mov	r1, r3
 8001f1c:	697b      	ldr	r3, [r7, #20]
 8001f1e:	b29b      	uxth	r3, r3
 8001f20:	fa01 f303 	lsl.w	r3, r1, r3
 8001f24:	b29b      	uxth	r3, r3
 8001f26:	431a      	orrs	r2, r3
 8001f28:	687b      	ldr	r3, [r7, #4]
 8001f2a:	605a      	str	r2, [r3, #4]
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8001f2c:	687b      	ldr	r3, [r7, #4]
 8001f2e:	68da      	ldr	r2, [r3, #12]
 8001f30:	697b      	ldr	r3, [r7, #20]
 8001f32:	b29b      	uxth	r3, r3
 8001f34:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8001f38:	f04f 0103 	mov.w	r1, #3
 8001f3c:	fa01 f303 	lsl.w	r3, r1, r3
 8001f40:	ea6f 0303 	mvn.w	r3, r3
 8001f44:	401a      	ands	r2, r3
 8001f46:	687b      	ldr	r3, [r7, #4]
 8001f48:	60da      	str	r2, [r3, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8001f4a:	687b      	ldr	r3, [r7, #4]
 8001f4c:	68da      	ldr	r2, [r3, #12]
 8001f4e:	683b      	ldr	r3, [r7, #0]
 8001f50:	79db      	ldrb	r3, [r3, #7]
 8001f52:	4619      	mov	r1, r3
 8001f54:	697b      	ldr	r3, [r7, #20]
 8001f56:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8001f5a:	fa01 f303 	lsl.w	r3, r1, r3
 8001f5e:	431a      	orrs	r2, r3
 8001f60:	687b      	ldr	r3, [r7, #4]
 8001f62:	60da      	str	r2, [r3, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8001f64:	697b      	ldr	r3, [r7, #20]
 8001f66:	f103 0301 	add.w	r3, r3, #1
 8001f6a:	617b      	str	r3, [r7, #20]
 8001f6c:	697b      	ldr	r3, [r7, #20]
 8001f6e:	2b0f      	cmp	r3, #15
 8001f70:	f67f af74 	bls.w	8001e5c <GPIO_Init+0x24>
      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
    }
  }
}
 8001f74:	f107 071c 	add.w	r7, r7, #28
 8001f78:	46bd      	mov	sp, r7
 8001f7a:	bc80      	pop	{r7}
 8001f7c:	4770      	bx	lr
 8001f7e:	bf00      	nop

08001f80 <GPIO_PinAFConfig>:
  *            @arg GPIO_AF_DCMI: Connect DCMI pins to AF13
  *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 8001f80:	b480      	push	{r7}
 8001f82:	b085      	sub	sp, #20
 8001f84:	af00      	add	r7, sp, #0
 8001f86:	6078      	str	r0, [r7, #4]
 8001f88:	4613      	mov	r3, r2
 8001f8a:	460a      	mov	r2, r1
 8001f8c:	807a      	strh	r2, [r7, #2]
 8001f8e:	707b      	strb	r3, [r7, #1]
  uint32_t temp = 0x00;
 8001f90:	f04f 0300 	mov.w	r3, #0
 8001f94:	60fb      	str	r3, [r7, #12]
  uint32_t temp_2 = 0x00;
 8001f96:	f04f 0300 	mov.w	r3, #0
 8001f9a:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8001f9c:	787a      	ldrb	r2, [r7, #1]
 8001f9e:	887b      	ldrh	r3, [r7, #2]
 8001fa0:	f003 0307 	and.w	r3, r3, #7
 8001fa4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001fa8:	fa02 f303 	lsl.w	r3, r2, r3
 8001fac:	60fb      	str	r3, [r7, #12]
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8001fae:	887b      	ldrh	r3, [r7, #2]
 8001fb0:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 8001fb4:	b29b      	uxth	r3, r3
 8001fb6:	461a      	mov	r2, r3
 8001fb8:	887b      	ldrh	r3, [r7, #2]
 8001fba:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 8001fbe:	b29b      	uxth	r3, r3
 8001fc0:	4619      	mov	r1, r3
 8001fc2:	687b      	ldr	r3, [r7, #4]
 8001fc4:	f101 0108 	add.w	r1, r1, #8
 8001fc8:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 8001fcc:	887b      	ldrh	r3, [r7, #2]
 8001fce:	f003 0307 	and.w	r3, r3, #7
 8001fd2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001fd6:	f04f 000f 	mov.w	r0, #15
 8001fda:	fa00 f303 	lsl.w	r3, r0, r3
 8001fde:	ea6f 0303 	mvn.w	r3, r3
 8001fe2:	4019      	ands	r1, r3
 8001fe4:	687b      	ldr	r3, [r7, #4]
 8001fe6:	f102 0208 	add.w	r2, r2, #8
 8001fea:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 8001fee:	887b      	ldrh	r3, [r7, #2]
 8001ff0:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 8001ff4:	b29b      	uxth	r3, r3
 8001ff6:	461a      	mov	r2, r3
 8001ff8:	687b      	ldr	r3, [r7, #4]
 8001ffa:	f102 0208 	add.w	r2, r2, #8
 8001ffe:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8002002:	68fb      	ldr	r3, [r7, #12]
 8002004:	ea42 0303 	orr.w	r3, r2, r3
 8002008:	60bb      	str	r3, [r7, #8]
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 800200a:	887b      	ldrh	r3, [r7, #2]
 800200c:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 8002010:	b29b      	uxth	r3, r3
 8002012:	461a      	mov	r2, r3
 8002014:	687b      	ldr	r3, [r7, #4]
 8002016:	f102 0208 	add.w	r2, r2, #8
 800201a:	68b9      	ldr	r1, [r7, #8]
 800201c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8002020:	f107 0714 	add.w	r7, r7, #20
 8002024:	46bd      	mov	sp, r7
 8002026:	bc80      	pop	{r7}
 8002028:	4770      	bx	lr
 800202a:	bf00      	nop

0800202c <RCC_GetClocksFreq>:
  *         configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 800202c:	b480      	push	{r7}
 800202e:	b089      	sub	sp, #36	; 0x24
 8002030:	af00      	add	r7, sp, #0
 8002032:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
 8002034:	f04f 0300 	mov.w	r3, #0
 8002038:	61bb      	str	r3, [r7, #24]
 800203a:	f04f 0300 	mov.w	r3, #0
 800203e:	617b      	str	r3, [r7, #20]
 8002040:	f04f 0300 	mov.w	r3, #0
 8002044:	61fb      	str	r3, [r7, #28]
 8002046:	f04f 0302 	mov.w	r3, #2
 800204a:	613b      	str	r3, [r7, #16]
 800204c:	f04f 0300 	mov.w	r3, #0
 8002050:	60fb      	str	r3, [r7, #12]
 8002052:	f04f 0302 	mov.w	r3, #2
 8002056:	60bb      	str	r3, [r7, #8]

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8002058:	4b4f      	ldr	r3, [pc, #316]	; (8002198 <RCC_GetClocksFreq+0x16c>)
 800205a:	689b      	ldr	r3, [r3, #8]
 800205c:	f003 030c 	and.w	r3, r3, #12
 8002060:	61bb      	str	r3, [r7, #24]

  switch (tmp)
 8002062:	69bb      	ldr	r3, [r7, #24]
 8002064:	2b04      	cmp	r3, #4
 8002066:	d007      	beq.n	8002078 <RCC_GetClocksFreq+0x4c>
 8002068:	2b08      	cmp	r3, #8
 800206a:	d009      	beq.n	8002080 <RCC_GetClocksFreq+0x54>
 800206c:	2b00      	cmp	r3, #0
 800206e:	d147      	bne.n	8002100 <RCC_GetClocksFreq+0xd4>
  {
    case 0x00:  /* HSI used as system clock source */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8002070:	687b      	ldr	r3, [r7, #4]
 8002072:	4a4a      	ldr	r2, [pc, #296]	; (800219c <RCC_GetClocksFreq+0x170>)
 8002074:	601a      	str	r2, [r3, #0]
      break;
 8002076:	e047      	b.n	8002108 <RCC_GetClocksFreq+0xdc>
    case 0x04:  /* HSE used as system clock  source */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 8002078:	687b      	ldr	r3, [r7, #4]
 800207a:	4a49      	ldr	r2, [pc, #292]	; (80021a0 <RCC_GetClocksFreq+0x174>)
 800207c:	601a      	str	r2, [r3, #0]
      break;
 800207e:	e043      	b.n	8002108 <RCC_GetClocksFreq+0xdc>
    case 0x08:  /* PLL used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 8002080:	4b45      	ldr	r3, [pc, #276]	; (8002198 <RCC_GetClocksFreq+0x16c>)
 8002082:	685b      	ldr	r3, [r3, #4]
 8002084:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8002088:	ea4f 5393 	mov.w	r3, r3, lsr #22
 800208c:	60fb      	str	r3, [r7, #12]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800208e:	4b42      	ldr	r3, [pc, #264]	; (8002198 <RCC_GetClocksFreq+0x16c>)
 8002090:	685b      	ldr	r3, [r3, #4]
 8002092:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8002096:	60bb      	str	r3, [r7, #8]
      
      if (pllsource != 0)
 8002098:	68fb      	ldr	r3, [r7, #12]
 800209a:	2b00      	cmp	r3, #0
 800209c:	d00f      	beq.n	80020be <RCC_GetClocksFreq+0x92>
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 800209e:	4a40      	ldr	r2, [pc, #256]	; (80021a0 <RCC_GetClocksFreq+0x174>)
 80020a0:	68bb      	ldr	r3, [r7, #8]
 80020a2:	fbb2 f2f3 	udiv	r2, r2, r3
 80020a6:	4b3c      	ldr	r3, [pc, #240]	; (8002198 <RCC_GetClocksFreq+0x16c>)
 80020a8:	6859      	ldr	r1, [r3, #4]
 80020aa:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 80020ae:	ea01 0303 	and.w	r3, r1, r3
 80020b2:	ea4f 1393 	mov.w	r3, r3, lsr #6
 80020b6:	fb03 f302 	mul.w	r3, r3, r2
 80020ba:	61fb      	str	r3, [r7, #28]
 80020bc:	e00e      	b.n	80020dc <RCC_GetClocksFreq+0xb0>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 80020be:	4a37      	ldr	r2, [pc, #220]	; (800219c <RCC_GetClocksFreq+0x170>)
 80020c0:	68bb      	ldr	r3, [r7, #8]
 80020c2:	fbb2 f2f3 	udiv	r2, r2, r3
 80020c6:	4b34      	ldr	r3, [pc, #208]	; (8002198 <RCC_GetClocksFreq+0x16c>)
 80020c8:	6859      	ldr	r1, [r3, #4]
 80020ca:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 80020ce:	ea01 0303 	and.w	r3, r1, r3
 80020d2:	ea4f 1393 	mov.w	r3, r3, lsr #6
 80020d6:	fb03 f302 	mul.w	r3, r3, r2
 80020da:	61fb      	str	r3, [r7, #28]
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 80020dc:	4b2e      	ldr	r3, [pc, #184]	; (8002198 <RCC_GetClocksFreq+0x16c>)
 80020de:	685b      	ldr	r3, [r3, #4]
 80020e0:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 80020e4:	ea4f 4313 	mov.w	r3, r3, lsr #16
 80020e8:	f103 0301 	add.w	r3, r3, #1
 80020ec:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80020f0:	613b      	str	r3, [r7, #16]
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 80020f2:	69fa      	ldr	r2, [r7, #28]
 80020f4:	693b      	ldr	r3, [r7, #16]
 80020f6:	fbb2 f2f3 	udiv	r2, r2, r3
 80020fa:	687b      	ldr	r3, [r7, #4]
 80020fc:	601a      	str	r2, [r3, #0]
      break;
 80020fe:	e003      	b.n	8002108 <RCC_GetClocksFreq+0xdc>
    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8002100:	687b      	ldr	r3, [r7, #4]
 8002102:	4a26      	ldr	r2, [pc, #152]	; (800219c <RCC_GetClocksFreq+0x170>)
 8002104:	601a      	str	r2, [r3, #0]
      break;
 8002106:	bf00      	nop
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 8002108:	4b23      	ldr	r3, [pc, #140]	; (8002198 <RCC_GetClocksFreq+0x16c>)
 800210a:	689b      	ldr	r3, [r3, #8]
 800210c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8002110:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 4;
 8002112:	69bb      	ldr	r3, [r7, #24]
 8002114:	ea4f 1313 	mov.w	r3, r3, lsr #4
 8002118:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 800211a:	4a22      	ldr	r2, [pc, #136]	; (80021a4 <RCC_GetClocksFreq+0x178>)
 800211c:	69bb      	ldr	r3, [r7, #24]
 800211e:	18d3      	adds	r3, r2, r3
 8002120:	781b      	ldrb	r3, [r3, #0]
 8002122:	b2db      	uxtb	r3, r3
 8002124:	617b      	str	r3, [r7, #20]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 8002126:	687b      	ldr	r3, [r7, #4]
 8002128:	681a      	ldr	r2, [r3, #0]
 800212a:	697b      	ldr	r3, [r7, #20]
 800212c:	fa22 f203 	lsr.w	r2, r2, r3
 8002130:	687b      	ldr	r3, [r7, #4]
 8002132:	605a      	str	r2, [r3, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 8002134:	4b18      	ldr	r3, [pc, #96]	; (8002198 <RCC_GetClocksFreq+0x16c>)
 8002136:	689b      	ldr	r3, [r3, #8]
 8002138:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
 800213c:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 10;
 800213e:	69bb      	ldr	r3, [r7, #24]
 8002140:	ea4f 2393 	mov.w	r3, r3, lsr #10
 8002144:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 8002146:	4a17      	ldr	r2, [pc, #92]	; (80021a4 <RCC_GetClocksFreq+0x178>)
 8002148:	69bb      	ldr	r3, [r7, #24]
 800214a:	18d3      	adds	r3, r2, r3
 800214c:	781b      	ldrb	r3, [r3, #0]
 800214e:	b2db      	uxtb	r3, r3
 8002150:	617b      	str	r3, [r7, #20]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8002152:	687b      	ldr	r3, [r7, #4]
 8002154:	685a      	ldr	r2, [r3, #4]
 8002156:	697b      	ldr	r3, [r7, #20]
 8002158:	fa22 f203 	lsr.w	r2, r2, r3
 800215c:	687b      	ldr	r3, [r7, #4]
 800215e:	609a      	str	r2, [r3, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 8002160:	4b0d      	ldr	r3, [pc, #52]	; (8002198 <RCC_GetClocksFreq+0x16c>)
 8002162:	689b      	ldr	r3, [r3, #8]
 8002164:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 8002168:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 13;
 800216a:	69bb      	ldr	r3, [r7, #24]
 800216c:	ea4f 3353 	mov.w	r3, r3, lsr #13
 8002170:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 8002172:	4a0c      	ldr	r2, [pc, #48]	; (80021a4 <RCC_GetClocksFreq+0x178>)
 8002174:	69bb      	ldr	r3, [r7, #24]
 8002176:	18d3      	adds	r3, r2, r3
 8002178:	781b      	ldrb	r3, [r3, #0]
 800217a:	b2db      	uxtb	r3, r3
 800217c:	617b      	str	r3, [r7, #20]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 800217e:	687b      	ldr	r3, [r7, #4]
 8002180:	685a      	ldr	r2, [r3, #4]
 8002182:	697b      	ldr	r3, [r7, #20]
 8002184:	fa22 f203 	lsr.w	r2, r2, r3
 8002188:	687b      	ldr	r3, [r7, #4]
 800218a:	60da      	str	r2, [r3, #12]
}
 800218c:	f107 0724 	add.w	r7, r7, #36	; 0x24
 8002190:	46bd      	mov	sp, r7
 8002192:	bc80      	pop	{r7}
 8002194:	4770      	bx	lr
 8002196:	bf00      	nop
 8002198:	40023800 	.word	0x40023800
 800219c:	00f42400 	.word	0x00f42400
 80021a0:	007a1200 	.word	0x007a1200
 80021a4:	20000534 	.word	0x20000534

080021a8 <RCC_AHB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
 80021a8:	b480      	push	{r7}
 80021aa:	b083      	sub	sp, #12
 80021ac:	af00      	add	r7, sp, #0
 80021ae:	6078      	str	r0, [r7, #4]
 80021b0:	460b      	mov	r3, r1
 80021b2:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80021b4:	78fb      	ldrb	r3, [r7, #3]
 80021b6:	2b00      	cmp	r3, #0
 80021b8:	d007      	beq.n	80021ca <RCC_AHB1PeriphClockCmd+0x22>
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
 80021ba:	4b0b      	ldr	r3, [pc, #44]	; (80021e8 <RCC_AHB1PeriphClockCmd+0x40>)
 80021bc:	4a0a      	ldr	r2, [pc, #40]	; (80021e8 <RCC_AHB1PeriphClockCmd+0x40>)
 80021be:	6b11      	ldr	r1, [r2, #48]	; 0x30
 80021c0:	687a      	ldr	r2, [r7, #4]
 80021c2:	ea41 0202 	orr.w	r2, r1, r2
 80021c6:	631a      	str	r2, [r3, #48]	; 0x30
 80021c8:	e008      	b.n	80021dc <RCC_AHB1PeriphClockCmd+0x34>
  }
  else
  {
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
 80021ca:	4b07      	ldr	r3, [pc, #28]	; (80021e8 <RCC_AHB1PeriphClockCmd+0x40>)
 80021cc:	4a06      	ldr	r2, [pc, #24]	; (80021e8 <RCC_AHB1PeriphClockCmd+0x40>)
 80021ce:	6b11      	ldr	r1, [r2, #48]	; 0x30
 80021d0:	687a      	ldr	r2, [r7, #4]
 80021d2:	ea6f 0202 	mvn.w	r2, r2
 80021d6:	ea01 0202 	and.w	r2, r1, r2
 80021da:	631a      	str	r2, [r3, #48]	; 0x30
  }
}
 80021dc:	f107 070c 	add.w	r7, r7, #12
 80021e0:	46bd      	mov	sp, r7
 80021e2:	bc80      	pop	{r7}
 80021e4:	4770      	bx	lr
 80021e6:	bf00      	nop
 80021e8:	40023800 	.word	0x40023800

080021ec <RCC_APB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 80021ec:	b480      	push	{r7}
 80021ee:	b083      	sub	sp, #12
 80021f0:	af00      	add	r7, sp, #0
 80021f2:	6078      	str	r0, [r7, #4]
 80021f4:	460b      	mov	r3, r1
 80021f6:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80021f8:	78fb      	ldrb	r3, [r7, #3]
 80021fa:	2b00      	cmp	r3, #0
 80021fc:	d007      	beq.n	800220e <RCC_APB1PeriphClockCmd+0x22>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 80021fe:	4b0b      	ldr	r3, [pc, #44]	; (800222c <RCC_APB1PeriphClockCmd+0x40>)
 8002200:	4a0a      	ldr	r2, [pc, #40]	; (800222c <RCC_APB1PeriphClockCmd+0x40>)
 8002202:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8002204:	687a      	ldr	r2, [r7, #4]
 8002206:	ea41 0202 	orr.w	r2, r1, r2
 800220a:	641a      	str	r2, [r3, #64]	; 0x40
 800220c:	e008      	b.n	8002220 <RCC_APB1PeriphClockCmd+0x34>
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 800220e:	4b07      	ldr	r3, [pc, #28]	; (800222c <RCC_APB1PeriphClockCmd+0x40>)
 8002210:	4a06      	ldr	r2, [pc, #24]	; (800222c <RCC_APB1PeriphClockCmd+0x40>)
 8002212:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8002214:	687a      	ldr	r2, [r7, #4]
 8002216:	ea6f 0202 	mvn.w	r2, r2
 800221a:	ea01 0202 	and.w	r2, r1, r2
 800221e:	641a      	str	r2, [r3, #64]	; 0x40
  }
}
 8002220:	f107 070c 	add.w	r7, r7, #12
 8002224:	46bd      	mov	sp, r7
 8002226:	bc80      	pop	{r7}
 8002228:	4770      	bx	lr
 800222a:	bf00      	nop
 800222c:	40023800 	.word	0x40023800

08002230 <USART_Init>:
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
  *         the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8002230:	b580      	push	{r7, lr}
 8002232:	b08a      	sub	sp, #40	; 0x28
 8002234:	af00      	add	r7, sp, #0
 8002236:	6078      	str	r0, [r7, #4]
 8002238:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0x00, apbclock = 0x00;
 800223a:	f04f 0300 	mov.w	r3, #0
 800223e:	627b      	str	r3, [r7, #36]	; 0x24
 8002240:	f04f 0300 	mov.w	r3, #0
 8002244:	623b      	str	r3, [r7, #32]
  uint32_t integerdivider = 0x00;
 8002246:	f04f 0300 	mov.w	r3, #0
 800224a:	61fb      	str	r3, [r7, #28]
  uint32_t fractionaldivider = 0x00;
 800224c:	f04f 0300 	mov.w	r3, #0
 8002250:	61bb      	str	r3, [r7, #24]
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  }

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8002252:	687b      	ldr	r3, [r7, #4]
 8002254:	8a1b      	ldrh	r3, [r3, #16]
 8002256:	b29b      	uxth	r3, r3
 8002258:	627b      	str	r3, [r7, #36]	; 0x24

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 800225a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800225c:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8002260:	627b      	str	r3, [r7, #36]	; 0x24

  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
      Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 8002262:	683b      	ldr	r3, [r7, #0]
 8002264:	88db      	ldrh	r3, [r3, #6]
 8002266:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8002268:	ea42 0303 	orr.w	r3, r2, r3
 800226c:	627b      	str	r3, [r7, #36]	; 0x24
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 800226e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002270:	b29a      	uxth	r2, r3
 8002272:	687b      	ldr	r3, [r7, #4]
 8002274:	821a      	strh	r2, [r3, #16]

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 8002276:	687b      	ldr	r3, [r7, #4]
 8002278:	899b      	ldrh	r3, [r3, #12]
 800227a:	b29b      	uxth	r3, r3
 800227c:	627b      	str	r3, [r7, #36]	; 0x24

  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 800227e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002280:	f423 53b0 	bic.w	r3, r3, #5632	; 0x1600
 8002284:	f023 030c 	bic.w	r3, r3, #12
 8002288:	627b      	str	r3, [r7, #36]	; 0x24

  /* Configure the USART Word Length, Parity and mode: 
     Set the M bits according to USART_WordLength value 
     Set PCE and PS bits according to USART_Parity value
     Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 800228a:	683b      	ldr	r3, [r7, #0]
 800228c:	889a      	ldrh	r2, [r3, #4]
 800228e:	683b      	ldr	r3, [r7, #0]
 8002290:	891b      	ldrh	r3, [r3, #8]
 8002292:	ea42 0303 	orr.w	r3, r2, r3
 8002296:	b29a      	uxth	r2, r3
            USART_InitStruct->USART_Mode;
 8002298:	683b      	ldr	r3, [r7, #0]
 800229a:	895b      	ldrh	r3, [r3, #10]

  /* Configure the USART Word Length, Parity and mode: 
     Set the M bits according to USART_WordLength value 
     Set PCE and PS bits according to USART_Parity value
     Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 800229c:	ea42 0303 	orr.w	r3, r2, r3
 80022a0:	b29b      	uxth	r3, r3
 80022a2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80022a4:	ea42 0303 	orr.w	r3, r2, r3
 80022a8:	627b      	str	r3, [r7, #36]	; 0x24
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 80022aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80022ac:	b29a      	uxth	r2, r3
 80022ae:	687b      	ldr	r3, [r7, #4]
 80022b0:	819a      	strh	r2, [r3, #12]

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 80022b2:	687b      	ldr	r3, [r7, #4]
 80022b4:	8a9b      	ldrh	r3, [r3, #20]
 80022b6:	b29b      	uxth	r3, r3
 80022b8:	627b      	str	r3, [r7, #36]	; 0x24

  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
 80022ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80022bc:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80022c0:	627b      	str	r3, [r7, #36]	; 0x24

  /* Configure the USART HFC : 
      Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 80022c2:	683b      	ldr	r3, [r7, #0]
 80022c4:	899b      	ldrh	r3, [r3, #12]
 80022c6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80022c8:	ea42 0303 	orr.w	r3, r2, r3
 80022cc:	627b      	str	r3, [r7, #36]	; 0x24

  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 80022ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80022d0:	b29a      	uxth	r2, r3
 80022d2:	687b      	ldr	r3, [r7, #4]
 80022d4:	829a      	strh	r2, [r3, #20]

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate */
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 80022d6:	f107 0308 	add.w	r3, r7, #8
 80022da:	4618      	mov	r0, r3
 80022dc:	f7ff fea6 	bl	800202c <RCC_GetClocksFreq>

  if ((USARTx == USART1) || (USARTx == USART6))
 80022e0:	687a      	ldr	r2, [r7, #4]
 80022e2:	4b3a      	ldr	r3, [pc, #232]	; (80023cc <USART_Init+0x19c>)
 80022e4:	429a      	cmp	r2, r3
 80022e6:	d003      	beq.n	80022f0 <USART_Init+0xc0>
 80022e8:	687a      	ldr	r2, [r7, #4]
 80022ea:	4b39      	ldr	r3, [pc, #228]	; (80023d0 <USART_Init+0x1a0>)
 80022ec:	429a      	cmp	r2, r3
 80022ee:	d102      	bne.n	80022f6 <USART_Init+0xc6>
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 80022f0:	697b      	ldr	r3, [r7, #20]
 80022f2:	623b      	str	r3, [r7, #32]
 80022f4:	e001      	b.n	80022fa <USART_Init+0xca>
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 80022f6:	693b      	ldr	r3, [r7, #16]
 80022f8:	623b      	str	r3, [r7, #32]
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 80022fa:	687b      	ldr	r3, [r7, #4]
 80022fc:	899b      	ldrh	r3, [r3, #12]
 80022fe:	b29b      	uxth	r3, r3
 8002300:	b29b      	uxth	r3, r3
 8002302:	b21b      	sxth	r3, r3
 8002304:	2b00      	cmp	r3, #0
 8002306:	da0f      	bge.n	8002328 <USART_Init+0xf8>
  {
    /* Integer part computing in case Oversampling mode is 8 Samples */
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 8002308:	6a3a      	ldr	r2, [r7, #32]
 800230a:	4613      	mov	r3, r2
 800230c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002310:	189b      	adds	r3, r3, r2
 8002312:	ea4f 0283 	mov.w	r2, r3, lsl #2
 8002316:	189a      	adds	r2, r3, r2
 8002318:	683b      	ldr	r3, [r7, #0]
 800231a:	681b      	ldr	r3, [r3, #0]
 800231c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8002320:	fbb2 f3f3 	udiv	r3, r2, r3
 8002324:	61fb      	str	r3, [r7, #28]
 8002326:	e00e      	b.n	8002346 <USART_Init+0x116>
  }
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 8002328:	6a3a      	ldr	r2, [r7, #32]
 800232a:	4613      	mov	r3, r2
 800232c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002330:	189b      	adds	r3, r3, r2
 8002332:	ea4f 0283 	mov.w	r2, r3, lsl #2
 8002336:	189a      	adds	r2, r3, r2
 8002338:	683b      	ldr	r3, [r7, #0]
 800233a:	681b      	ldr	r3, [r3, #0]
 800233c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002340:	fbb2 f3f3 	udiv	r3, r2, r3
 8002344:	61fb      	str	r3, [r7, #28]
  }
  tmpreg = (integerdivider / 100) << 4;
 8002346:	69fa      	ldr	r2, [r7, #28]
 8002348:	4b22      	ldr	r3, [pc, #136]	; (80023d4 <USART_Init+0x1a4>)
 800234a:	fba3 1302 	umull	r1, r3, r3, r2
 800234e:	ea4f 1353 	mov.w	r3, r3, lsr #5
 8002352:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002356:	627b      	str	r3, [r7, #36]	; 0x24

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 8002358:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800235a:	ea4f 1313 	mov.w	r3, r3, lsr #4
 800235e:	f04f 0264 	mov.w	r2, #100	; 0x64
 8002362:	fb02 f303 	mul.w	r3, r2, r3
 8002366:	69fa      	ldr	r2, [r7, #28]
 8002368:	1ad3      	subs	r3, r2, r3
 800236a:	61bb      	str	r3, [r7, #24]

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 800236c:	687b      	ldr	r3, [r7, #4]
 800236e:	899b      	ldrh	r3, [r3, #12]
 8002370:	b29b      	uxth	r3, r3
 8002372:	b29b      	uxth	r3, r3
 8002374:	b21b      	sxth	r3, r3
 8002376:	2b00      	cmp	r3, #0
 8002378:	da10      	bge.n	800239c <USART_Init+0x16c>
  {
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 800237a:	69bb      	ldr	r3, [r7, #24]
 800237c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8002380:	f103 0232 	add.w	r2, r3, #50	; 0x32
 8002384:	4b13      	ldr	r3, [pc, #76]	; (80023d4 <USART_Init+0x1a4>)
 8002386:	fba3 1302 	umull	r1, r3, r3, r2
 800238a:	ea4f 1353 	mov.w	r3, r3, lsr #5
 800238e:	f003 0307 	and.w	r3, r3, #7
 8002392:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8002394:	ea42 0303 	orr.w	r3, r2, r3
 8002398:	627b      	str	r3, [r7, #36]	; 0x24
 800239a:	e00f      	b.n	80023bc <USART_Init+0x18c>
  }
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 800239c:	69bb      	ldr	r3, [r7, #24]
 800239e:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80023a2:	f103 0232 	add.w	r2, r3, #50	; 0x32
 80023a6:	4b0b      	ldr	r3, [pc, #44]	; (80023d4 <USART_Init+0x1a4>)
 80023a8:	fba3 1302 	umull	r1, r3, r3, r2
 80023ac:	ea4f 1353 	mov.w	r3, r3, lsr #5
 80023b0:	f003 030f 	and.w	r3, r3, #15
 80023b4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80023b6:	ea42 0303 	orr.w	r3, r2, r3
 80023ba:	627b      	str	r3, [r7, #36]	; 0x24
  }
  
  /* Write to USART BRR register */
  USARTx->BRR = (uint16_t)tmpreg;
 80023bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80023be:	b29a      	uxth	r2, r3
 80023c0:	687b      	ldr	r3, [r7, #4]
 80023c2:	811a      	strh	r2, [r3, #8]
}
 80023c4:	f107 0728 	add.w	r7, r7, #40	; 0x28
 80023c8:	46bd      	mov	sp, r7
 80023ca:	bd80      	pop	{r7, pc}
 80023cc:	40011000 	.word	0x40011000
 80023d0:	40011400 	.word	0x40011400
 80023d4:	51eb851f 	.word	0x51eb851f

080023d8 <USART_Cmd>:
  * @param  NewState: new state of the USARTx peripheral.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
 80023d8:	b480      	push	{r7}
 80023da:	b083      	sub	sp, #12
 80023dc:	af00      	add	r7, sp, #0
 80023de:	6078      	str	r0, [r7, #4]
 80023e0:	460b      	mov	r3, r1
 80023e2:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80023e4:	78fb      	ldrb	r3, [r7, #3]
 80023e6:	2b00      	cmp	r3, #0
 80023e8:	d008      	beq.n	80023fc <USART_Cmd+0x24>
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_UE;
 80023ea:	687b      	ldr	r3, [r7, #4]
 80023ec:	899b      	ldrh	r3, [r3, #12]
 80023ee:	b29b      	uxth	r3, r3
 80023f0:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80023f4:	b29a      	uxth	r2, r3
 80023f6:	687b      	ldr	r3, [r7, #4]
 80023f8:	819a      	strh	r2, [r3, #12]
 80023fa:	e007      	b.n	800240c <USART_Cmd+0x34>
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
 80023fc:	687b      	ldr	r3, [r7, #4]
 80023fe:	899b      	ldrh	r3, [r3, #12]
 8002400:	b29b      	uxth	r3, r3
 8002402:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8002406:	b29a      	uxth	r2, r3
 8002408:	687b      	ldr	r3, [r7, #4]
 800240a:	819a      	strh	r2, [r3, #12]
  }
}
 800240c:	f107 070c 	add.w	r7, r7, #12
 8002410:	46bd      	mov	sp, r7
 8002412:	bc80      	pop	{r7}
 8002414:	4770      	bx	lr
 8002416:	bf00      	nop

08002418 <USART_SendData>:
  *         UART peripheral.
  * @param  Data: the data to transmit.
  * @retval None
  */
void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
{
 8002418:	b480      	push	{r7}
 800241a:	b083      	sub	sp, #12
 800241c:	af00      	add	r7, sp, #0
 800241e:	6078      	str	r0, [r7, #4]
 8002420:	460b      	mov	r3, r1
 8002422:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DATA(Data)); 
    
  /* Transmit Data */
  USARTx->DR = (Data & (uint16_t)0x01FF);
 8002424:	887b      	ldrh	r3, [r7, #2]
 8002426:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 800242a:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 800242e:	b29a      	uxth	r2, r3
 8002430:	687b      	ldr	r3, [r7, #4]
 8002432:	809a      	strh	r2, [r3, #4]
}
 8002434:	f107 070c 	add.w	r7, r7, #12
 8002438:	46bd      	mov	sp, r7
 800243a:	bc80      	pop	{r7}
 800243c:	4770      	bx	lr
 800243e:	bf00      	nop

08002440 <USART_ReceiveData>:
  * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
  *         UART peripheral.
  * @retval The received data.
  */
uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
{
 8002440:	b480      	push	{r7}
 8002442:	b083      	sub	sp, #12
 8002444:	af00      	add	r7, sp, #0
 8002446:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Receive Data */
  return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
 8002448:	687b      	ldr	r3, [r7, #4]
 800244a:	889b      	ldrh	r3, [r3, #4]
 800244c:	b29b      	uxth	r3, r3
 800244e:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 8002452:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 8002456:	b29b      	uxth	r3, r3
}
 8002458:	4618      	mov	r0, r3
 800245a:	f107 070c 	add.w	r7, r7, #12
 800245e:	46bd      	mov	sp, r7
 8002460:	bc80      	pop	{r7}
 8002462:	4770      	bx	lr

08002464 <USART_GetFlagStatus>:
  *            @arg USART_FLAG_FE:   Framing Error flag
  *            @arg USART_FLAG_PE:   Parity Error flag
  * @retval The new state of USART_FLAG (SET or RESET).
  */
FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
{
 8002464:	b480      	push	{r7}
 8002466:	b085      	sub	sp, #20
 8002468:	af00      	add	r7, sp, #0
 800246a:	6078      	str	r0, [r7, #4]
 800246c:	460b      	mov	r3, r1
 800246e:	807b      	strh	r3, [r7, #2]
  FlagStatus bitstatus = RESET;
 8002470:	f04f 0300 	mov.w	r3, #0
 8002474:	73fb      	strb	r3, [r7, #15]
  if (USART_FLAG == USART_FLAG_CTS)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
    
  if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
 8002476:	687b      	ldr	r3, [r7, #4]
 8002478:	881b      	ldrh	r3, [r3, #0]
 800247a:	b29a      	uxth	r2, r3
 800247c:	887b      	ldrh	r3, [r7, #2]
 800247e:	ea02 0303 	and.w	r3, r2, r3
 8002482:	b29b      	uxth	r3, r3
 8002484:	2b00      	cmp	r3, #0
 8002486:	d003      	beq.n	8002490 <USART_GetFlagStatus+0x2c>
  {
    bitstatus = SET;
 8002488:	f04f 0301 	mov.w	r3, #1
 800248c:	73fb      	strb	r3, [r7, #15]
 800248e:	e002      	b.n	8002496 <USART_GetFlagStatus+0x32>
  }
  else
  {
    bitstatus = RESET;
 8002490:	f04f 0300 	mov.w	r3, #0
 8002494:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 8002496:	7bfb      	ldrb	r3, [r7, #15]
}
 8002498:	4618      	mov	r0, r3
 800249a:	f107 0714 	add.w	r7, r7, #20
 800249e:	46bd      	mov	sp, r7
 80024a0:	bc80      	pop	{r7}
 80024a2:	4770      	bx	lr
 80024a4:	72617355 	.word	0x72617355
 80024a8:	73615474 	.word	0x73615474
 80024ac:	0000006b 	.word	0x0000006b
 80024b0:	454c4449 	.word	0x454c4449
 80024b4:	00000000 	.word	0x00000000
 80024b8:	00000a0d 	.word	0x00000a0d
 80024bc:	20207525 	.word	0x20207525
 80024c0:	20206325 	.word	0x20206325
 80024c4:	36312d25 	.word	0x36312d25
 80024c8:	20202073 	.word	0x20202073
 80024cc:	20202020 	.word	0x20202020
 80024d0:	30202020 	.word	0x30202020
 80024d4:	30202020 	.word	0x30202020
 80024d8:	20202525 	.word	0x20202525
 80024dc:	0d753525 	.word	0x0d753525
 80024e0:	0000000a 	.word	0x0000000a
 80024e4:	20207525 	.word	0x20207525
 80024e8:	20206325 	.word	0x20206325
 80024ec:	36312d25 	.word	0x36312d25
 80024f0:	31252073 	.word	0x31252073
 80024f4:	25207530 	.word	0x25207530
 80024f8:	25257533 	.word	0x25257533
 80024fc:	35252020 	.word	0x35252020
 8002500:	000a0d75 	.word	0x000a0d75
 8002504:	20207525 	.word	0x20207525
 8002508:	20206325 	.word	0x20206325
 800250c:	36312d25 	.word	0x36312d25
 8002510:	31252073 	.word	0x31252073
 8002514:	20207530 	.word	0x20207530
 8002518:	2525313c 	.word	0x2525313c
 800251c:	35252020 	.word	0x35252020
 8002520:	000a0d75 	.word	0x000a0d75

08002524 <_global_impure_ptr>:
 8002524:	20000004                                ... 

08002528 <__sf_fake_stdin>:
 8002528:	00000000 00000000 00000000 00000000     ................
 8002538:	00000000 00000000 00000000 00000000     ................

08002548 <__sf_fake_stdout>:
 8002548:	00000000 00000000 00000000 00000000     ................
 8002558:	00000000 00000000 00000000 00000000     ................

08002568 <__sf_fake_stderr>:
 8002568:	00000000 00000000 00000000 00000000     ................
 8002578:	00000000 00000000 00000000 00000000     ................
 8002588:	00000043                                C...

0800258c <_init>:
 800258c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800258e:	bf00      	nop
 8002590:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8002592:	bc08      	pop	{r3}
 8002594:	469e      	mov	lr, r3
 8002596:	4770      	bx	lr

08002598 <_fini>:
 8002598:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800259a:	bf00      	nop
 800259c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800259e:	bc08      	pop	{r3}
 80025a0:	469e      	mov	lr, r3
 80025a2:	4770      	bx	lr
